# SOW: CHASE-122: イベントからNotification一覧を生成する仕組みの実装（送信は別課題）

## プロジェクト概要

**課題ID**: CHASE-122
**作成日**: 2025-09-06
**種別**: 新機能開発

## 1. 背景と目的

### 背景

GitHub リポジトリ監視アプリケーションにおいて、ユーザーがウォッチしているリポジトリでイベント（リリース、PR、Issue等）が発生した際、ユーザーに通知を行う仕組みが必要である。現在、イベントの収集・保存機能は存在するが、イベントから個別ユーザー向けの通知レコードを生成する機能が未実装である。

### 目的

- イベントテーブルに蓄積されたデータから、購読ユーザー向けの通知を「まとめて」生成する
- ユーザーの最終通知時刻を管理し、効率的な通知対象抽出を実現する
- 重複通知の防止と、1ユーザー複数イベントを1件の通知に集約する基盤を整備する
- 通知の実送信機能（別課題）で参照するための拡張しやすいデータ構造を整備する

### 設計上の留意事項

- 1回の処理で1人のユーザーに5つのイベントが発生していた場合、次のような処理が行いたいです。
  - DBには、1回のバッチ処理あたりnotificationsテーブル上に1つだけレコードを作成
    - notification_itemsテーブルに各eventに対応するレコードを作成
  - 後で実際に通知を行う際、notification_itemsテーブルから内容をまとめて取得して、通知文章を組み立てられるようにする
    - 今回の課題の範囲外ですが、実際に通知を行う際はメール通知の他、Slack通知なども行いたいと考えていて、
      そういった場合に通知先によって異なる通知文章を生成できる余地を残したいです。
  - また、notifications自体は「サービスからのお知らせ」のような用途にも使いたいと考えています
    - この場合はnotification_xxxテーブルのように2階層にする必要はなく、notificationsテーブルに直接本文を格納するのが向いているように思えます。

## 2. 実装スコープ

### 実装対象

- DBスキーマの拡張
  - `users.last_notified_at`（最終通知処理時刻）を追加
  - `notifications.scheduled_at`（送信予定時刻）を追加
  - `notification_items`（通知内のイベント明細）を新設（`id`, `notification_id`, `user_id`, `event_id`, `created_at`。一意制約: `(user_id, event_id)`）
- イベントからユーザー別に通知を集約するサービス層の実装
- ユーザーの購読設定に基づく通知対象の絞り込み
- 通知予定時刻（`scheduled_at`）の計算機能
- 重複作成防止（`notification_items` の一意制約 + `ON CONFLICT DO NOTHING`）
- **ユーザー向け公開API**：認証済みユーザーが自分の通知を手動生成
- **管理用Lambda Worker**：全ユーザーを対象とした一括処理（StepFunctions/Lambda直接呼び出し用）

### 更新可能な項目

1. ユーザーの最終通知時刻（`last_notified_at`）
2. 通知レコード（`notifications`）の生成・更新（1ユーザーにつき1件に集約）
3. 通知明細（`notification_items`）の生成（イベントごとに1行）
4. 通知予定時刻（`scheduled_at`）の設定

### 実装除外項目

- 通知の実送信処理（メール・Slack等）
- 定時実行Lambda の実装
- ユーザー通知設定UI（フロントエンド）
- 複雑なタイムゾーン処理（初期実装では固定時刻での実装）

## 3. 技術仕様

### API仕様

#### 1. ユーザー向け公開API

**エンドポイント**

```
POST /api/notifications/generate
```

**認証・認可**

- JWT認証必須
- 認証済みユーザーは自分の通知のみ生成可能
- レート制限：1分間に3回まで（乱用防止）

**リクエスト仕様**

```typescript
{
} // ボディは空（認証情報からユーザーIDを取得）
```

**レスポンス仕様**

```typescript
{
  "success": true,
  "data": {
    "userId": string,
    "generatedNotifications": number, // 通常は0または1
    "linkedEvents": number,           // 明細として紐付けたイベント件数
    "lastNotifiedAt": string | null,
    "message": string
  }
}
```

#### 2. 管理用Lambda Worker

**関数名**

```
generate-notifications
```

**呼び出し元**

- StepFunctions（定時実行、ユーザー列挙→チャンク分割→並列実行）
- Lambda直接呼び出し（運用・開発用途）

**入力イベント仕様**

```typescript
interface GenerateNotificationsInput {
  // ユーザーIDのチャンク。1人を対象にするときは1件だけの配列で渡す
  userIds: string[];
}
```

**出力仕様**

```typescript
interface GenerateNotificationsOutput {
  processedUsers: number;
  generatedNotifications: number; // 作成した notifications の件数（通常は processedUsers 以下）
  linkedEvents: number; // 生成した notification_items の総数
  errors: string[];
}
```

#### 3. 列挙用Lambda Worker

**関数名**

```
list-notification-users
```

**入力イベント仕様**

```typescript
interface ListNotificationUsersInput {
  chunkSize?: number; // 既定: env NOTIFICATION_USER_CHUNK_SIZE または 100
  onlyWithNotificationsEnabled?: boolean; // 既定: true（通知有効ユーザーのみ）
}
```

**出力仕様**

```typescript
interface ListNotificationUsersOutput {
  totalUsers: number;
  chunkSize: number;
  chunks: string[][]; // ユーザーIDのチャンク
}
```

**動作要件**

- `onlyWithNotificationsEnabled` が true の場合、`user_watches.notification_enabled = true` を少なくとも1件持つユーザーを対象
- 出力の `chunks` を `generate-notifications` に順次/並列で投入する前提

### データベース操作

- `users`: `last_notified_at` カラム追加（TIMESTAMP WITH TIME ZONE NULL）
- `notifications`: `scheduled_at` カラム追加（TIMESTAMP WITH TIME ZONE NULL）
  - `event_id` は削除（イベントとの関連は `notification_items` に統一）
- `notification_items`（新規）: 通知とイベントのN:1紐付け
  - カラム例: `id (PK)`, `notification_id (FK->notifications.id)`, `user_id (FK->users.id)`, `event_id (FK->events.id)`, `created_at`
  - 一意制約: `(user_id, event_id)`（同一ユーザーに同一イベントを二重通知しない）
- 読み取り対象: `events`, `user_watches`, `data_sources`, `users`
- 書き込み対象: `notifications`, `notification_items`, `users.last_notified_at`

### アーキテクチャ設計

既存のdata-sources機能と同じレイヤード構成を採用：

- **Domain層**: `Notification`, `NotificationItem`, `NotificationGenerationInput/Output`
- **Repository層**: `NotificationRepository`, `NotificationItemRepository`, `EventRepository`, `UserRepository`
- **Service層**: `NotificationAggregatorService`（ユーザー別にイベントを集約し1件の通知を作成、明細を `notification_items` に書き込む）
- **Presentation層**: 開発・テスト用の内部APIエンドポイント

#### 性能設計（複数ユーザー・タイムアウト対策）

- ユーザーはページング取得（例: 100件ずつ）。
- 1ページに対し、以下のような結合クエリでユーザー×イベント候補を一括抽出:
  - `user_watches uw` → `events e` を `uw.data_source_id = e.data_source_id` でJOIN
  - かつ `e.created_at > COALESCE(u.last_notified_at, now() - interval '7 days')`
  - 種別フィルタ（`watch_releases` 等）をWHERE条件で適用
- アプリ側でユーザー単位にグルーピングし、1ユーザーにつき1件の `notifications` を生成、各イベントを `notification_items` にINSERT（`ON CONFLICT (user_id, event_id) DO NOTHING`）。
- バッチ上限（デフォルト: 1ユーザーあたり最大10件）を定数化し、超過分は次回に回すか2件目の通知に切り分け。
- 定数は `NOTIFICATION_MAX_ITEMS_PER_USER` として管理（将来的にユーザー設定で上書き可能）。

#### バッチ分割・オーケストレーション

- StepFunctions で以下の2段構成を採用:
  - 列挙ステップ（ワーカー: `list-notification-users`）: `users` から対象ユーザーを取得（`last_notified_at` を考慮）、チャンク（例: 100ユーザー）に分割
  - 並列実行ステップ（ワーカー: `generate-notifications`）: 各チャンクを受け取り、集約通知を生成（Map state / SQS fan-out いずれか）
- 集約ワーカー（`generate-notifications`）は `userIds` を受け取り、ユーザー単位で集約通知を生成
- タイムアウトに近づいた場合は現在の進捗を出力して早期終了し、次回実行時に継続可能な設計

これを考えると、generate-notifications だけで全ユーザーへの通知を裁くのはパフォーマンス的に問題がありそうです。
ユーザーを列挙するジョブが前段にあり、それがユーザーIDのチャンクを生成し、そのチャンクを受け取ってgenerate-notificationsが動くのが良いかもしれません。

※1: 何件程度が妥当かはユーザーにより変化しそうです。将来的にはユーザー設定の項目になるかもしれません。
-->

#### 通知種別と拡張方針

- `notifications.notification_type` はテキスト（既存）を用い、`"system" | "event_summary" | "event_single"` 等を想定。
- システムからのお知らせ等は `notifications` に本文を直接格納（`notification_items` も不要）。
- イベント由来の通知は `notification_items`に情報を記録しておくにとどめる。
  実際に通知する際に、 `notification_items` からメッセージを作成して通知する。
  (通知先などによってイベント情報をどのようにまとめるかが異なるため、実際に通知するタイミングで決定する)

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/backend/src/features/notifications/domain/notification.ts`**
   - Notification、NotificationGenerationInput/Output型定義

2. **`packages/backend/src/features/notifications/domain/notification-item.ts`**
   - NotificationItem型定義

3. **`packages/backend/src/features/notifications/repositories/notification.repository.ts`**
   - 通知（`notifications`）および明細（`notification_items`）のCRUD操作

4. **`packages/backend/src/features/notifications/repositories/event.repository.ts`**
   - イベント抽出機能（日付範囲、購読設定による絞り込み）

5. **`packages/backend/src/features/notifications/repositories/user.repository.ts`**
   - ユーザーの最終通知時刻管理

6. **`packages/backend/src/features/notifications/services/notification-aggregator.service.ts`**
   - まとめ通知（集約）メインロジック

7. **`packages/backend/src/features/notifications/constants/notification.constants.ts`**
   - デフォルト通知時刻や`NOTIFICATION_MAX_ITEMS_PER_USER`の定数

8. **`packages/backend/src/features/notifications/presentation/routes/user-notifications/index.ts`**
   - ユーザー向け公開APIエンドポイント（JWT認証あり）

9. **`packages/backend/src/features/notifications/workers/generate-notifications/handler.ts`**
   - Lambda Worker本体（ユーザーチャンクを受けて一括処理）

10. **`packages/backend/src/features/notifications/workers/generate-notifications/index.ts`**
    - Lambda Workerエクスポート

11. **`packages/backend/src/features/notifications/workers/list-notification-users/handler.ts`**
    - 列挙ワーカー本体（対象ユーザーを抽出しチャンクに分割）

12. **`packages/backend/src/features/notifications/workers/list-notification-users/index.ts`**
    - 列挙ワーカーエクスポート

### 更新対象ファイル

1. **`packages/backend/src/db/schema.ts`**
   - `users` に `last_notified_at` を追加、`notifications` に `scheduled_at` を追加
   - `notifications.event_id` を削除（イベント関連は明細で管理）
   - `notification_items` を新設

2. **`packages/backend/src/features/notifications/presentation/index.ts`**
   - 既存の構成に合わせたエクスポート設定

3. **`packages/backend/src/test/factories.ts`**
   - `notification_items` 用のファクトリを追加
   - `createTestNotification` の拡張（明細を併せて生成するユーティリティの追加）

4. **DBマイグレーション運用（開発時）**
   - 手書きSQLは作成せず、`schema.ts` を更新後に `pnpm --filter backend db:generate` でマイグレーションを生成
   - 適用は `pnpm --filter backend db:migrate`

## 5. テスト戦略

### Component Test（Presentation層）

**ユーザー向け公開API（`POST /api/notifications/generate`）**

- 認証済みユーザーによる通知生成処理
- 未認証アクセスに対する401エラー
- レート制限の動作確認（1分間3回制限）
- 購読設定がないユーザーでも正常動作することの確認

**管理用Lambda Worker（`generate-notifications`）**

- 全ユーザーを対象とした通知生成処理
- 特定ユーザーを対象とした通知生成処理
- 購読していないユーザーへの通知が作成されないことの確認
- 重複実行時に重複レコードが作成されないことの確認
- Lambda コンテキストでの正常実行

**列挙用Lambda Worker（`list-notification-users`）**

- 指定 `chunkSize` でユーザーIDが分割される
- `onlyWithNotificationsEnabled` が true のとき、通知有効ユーザーのみが対象になる
- 出力の `totalUsers` と `chunks` 整合性の確認

### Unit Test（Service層）

- 抽出期間ロジック（last_notified_at が null の場合は7日前から）
- 抽出期間ロジック（last_notified_at がある場合はその時刻以降から）
- 通知予定時刻（scheduled_at）の計算ロジック
- 購読ユーザー解決ロジック
- 境界値テスト（ちょうど該当時刻のイベント）
- 1ユーザーに複数イベントがある場合でも1件の通知と複数の明細が生成されること

### Unit Test（Repository層）

- 通知レコード作成・更新処理
- イベント抽出処理（複数条件での絞り込み）
- ユーザー最終通知時刻の更新処理
- `notification_items (user_id, event_id)` 一意制約違反の適切な処理（ON CONFLICT DO NOTHING）

### Unit Test（Workers層）

- Lambda Worker のハンドラー関数テスト（`generate-notifications/handler.test.ts`）
- 入力イベントのバリデーション
- エラー処理とログ出力の確認

## 6. 受け入れ基準

### 機能要件

- [ ] ユーザーの`last_notified_at`が null の場合、抽出開始は「現在 - 7日」になる
- [ ] `last_notified_at`がある場合、その時刻より後のイベントのみが対象になる
- [ ] 購読していないユーザーには Notification が作成されない
- [ ] 1回の実行（1バッチ）につき、1ユーザーの複数イベントは1件のNotificationに集約される
- [ ] 複数回の実行にまたがって通知が作成されることはある（期間で区切られた別の集約通知）
- [ ] `notification_items` にイベント明細が作成される
- [ ] 同一ユーザーに同一イベントが二重作成されない（`notification_items (user_id, event_id)` の一意制約）
- [ ] ユーザーの通知設定（例: 毎日18:00）から適切な`scheduled_at`が計算され保存される
- [ ] サービスクラスのユニットテストが作成され、フィルタ条件と日付ロジックがカバーされている
- [ ] 列挙ワーカー（`list-notification-users`）が `chunkSize`・フィルタ条件に従ってチャンクを生成できる

### 非機能要件

- [ ] 既存のテストが全て通る
- [ ] 大量のイベント・ユーザーでもパフォーマンス劣化しない
- [ ] エラー処理が適切に実装されている

### セキュリティ要件

- [ ] JWT認証による適切なアクセス制御（ユーザー向けAPI）
- [ ] ユーザーは自分の通知のみ生成可能（権限分離）
- [ ] レート制限による乱用防止（1分間3回まで）
- [ ] Lambda WorkerとユーザーAPIの適切な分離
- [ ] SQLインジェクション対策が適切に実装されている
- [ ] ユーザー間のデータ分離が確保されている

## 7. 実装手順

### Phase 1: DBスキーマ・Repository層実装

- 1-1. `schema.ts` 更新（`users.last_notified_at`, `notifications.scheduled_at`, `notification_items`）
- 1-2. `pnpm --filter backend db:generate && pnpm --filter backend db:migrate`
- 1-3. NotificationRepository実装（CRUD操作；明細操作も内包）
- 1-4. EventRepository実装（抽出・絞り込み機能）
- 1-5. UserRepository実装（最終通知時刻管理）
- 1-6. Repository層のユニットテスト作成・実行

### Phase 2: Domain・Service層実装

- 2-1. Domain層の型定義作成
- 2-2. 定数ファイル作成
- 2-3. NotificationAggregatorService実装（集約・明細作成・重複防止）
- 2-4. Service層のユニットテスト作成・実行

### Phase 3: Presentation層・Workers層実装・統合テスト

- 3-1. ユーザー向け公開APIエンドポイント実装（JWT認証・レート制限含む）
- 3-2. Lambda Worker実装（`workers/generate-notifications`）
  - ユーザーをページングで処理（タイムアウト対策）
  - 1ユーザーあたり最大明細件数の上限を適用（定数化）
  - 二重実行時の冪等性（`notification_items` の一意制約）
- 3-3. Component テストの作成・実行（API・Workerのテスト）
- 3-4. 全体的な統合テスト・デバッグ

## 9. リスク・考慮事項

### 技術的リスク

- **データ量増大**: 大量のイベント・ユーザーでの処理性能問題
- **重複処理**: 同時実行時の重複通知作成
- **タイムゾーン**: 初期実装では簡素化するが、将来的に複雑化する可能性
- **メモリ使用量**: 大量の通知生成時のメモリ不足
- **レート制限回避**: 悪意のあるユーザーによるAPI乱用
- **認証負荷**: ユーザー向けAPIでのJWT認証処理コスト

### 軽減策

- バッチサイズによる処理分割
- トランザクション処理とユニーク制約（`notification_items (user_id, event_id)`）による重複防止
- レート制限とログ監視による乱用防止
- 認証処理の最適化とキャッシュ活用
- 段階的実装による品質確保
- 既存テストによる回帰テスト実施
- パフォーマンス監視・ロギングの充実
- 明細上限の定数化（例: 50件）とオーバーフロー時の次回繰越 or 分割通知
