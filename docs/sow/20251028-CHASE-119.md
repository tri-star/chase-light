# SOW: CHASE-119: Dashboardに通知一覧を表示する

## プロジェクト概要

**課題ID**: CHASE-119  
**作成日**: 2025-10-28  
**種別**: 機能改善

## 1. 背景と目的

### 背景

現状のダッシュボードでは「ウォッチ中のリポジトリ一覧」を中心に据えており、ユーザーが直近で受け取るべき通知情報がページ遷移なしでは確認できない。バックエンド側ではダイジェスト通知を集約するAPIが整備済みだが、フロントエンドのBFFとUIが未対応のため活用できていない。

### 目的

ダッシュボード上で未読の通知ダイジェストを一覧表示し、各通知に含まれるアクティビティを視覚的に把握できるようにする。これにより、ユーザーが重要な更新を素早く確認でき、通知中心の利用体験へ移行するための基盤を整備する。

## 2. 実装スコープ

### 実装対象

- フロントエンドBFFにおける `/api/notifications` ルートの実装
- Dashboardページでの通知リスト表示と無限スクロール導線
- 通知データを描画するVueコンポーネント群とテスト、Storybook
- Orval生成クライアント・Zodスキーマの更新とMSWモック拡充

### 更新可能な項目

1. Orval生成物の再生成 (`packages/frontend/generated/api/**/*`)
2. `packages/frontend/server/api/notifications/index.get.ts` の新規作成とZodバリデーション導入
3. `packages/frontend/components/pages/dashboard` 配下のロジック再構成（ページ用Composableの新設・既存ページの書き換え）
4. `packages/frontend/components/pages/dashboard/parts/NotificationList.vue` 新規実装と単体テスト追加
5. Dashboard関連Storybookのモックデータ刷新と通知API用MSWハンドラー設定

### 実装除外項目

- 通知の既読更新APIや既読状態の切り替えUI
- 通知詳細ページ遷移やモーダル表示の実装
- バックエンドAPIやDBスキーマの変更（既存機能を利用する）
- 通知以外のダッシュボード統計カードの仕様変更

## 3. 技術仕様

### API仕様

#### エンドポイント

```
GET /api/notifications
```

- フロントエンドBFF（Nuxt server/api）で実装し、Backendの `GET /api/notifications` をプロキシする。
- 既読状態は `read=unread` を既定値として付与し、初回は `limit=20` で取得。
- `cursor` が指定された場合はBackendへそのまま透過し、レスポンスの `pageInfo.nextCursor` をそのまま返却する。

#### 認証・認可

- 既存のAuth0セッションを利用し、BFFからBackendへのリクエストには `customFetch` によりBearerトークンを付与。
- 未認証時は `createError({ statusCode: 401 })` を返し、Backendのレスポンスに依存しない。

#### リクエスト仕様

```typescript
type GetNotificationsQuery = {
  cursor?: string;
  limit?: number; // 1-50, 既定値20
  read?: "all" | "read" | "unread"; // 既定値'unread'
  search?: string;
};
```

#### レスポンス仕様

```typescript
type NotificationDigestEntry = {
  activityId: string;
  title: string;
  summary: string;
  occurredAt: string; // ISO8601
  url: string | null;
};

type NotificationDigestGroup = {
  activityType: "issue" | "pull_request" | "release";
  entries: NotificationDigestEntry[]; // クライアント側で最大5件に整形
};

type NotificationDataSource = {
  id: string;
  name: string;
  url: string;
  sourceType: string;
  repository?: { fullName: string };
  groups: NotificationDigestGroup[];
};

type NotificationSummary = {
  id: string;
  type: string;
  status: string;
  isRead: boolean;
  scheduledAt: string;
  sentAt: string | null;
  createdAt: string;
  updatedAt: string;
  lastActivityOccurredAt: string;
  metadata: Record<string, unknown> | null;
};

type GetNotificationsResponse = {
  success: true;
  data: {
    items: Array<{
      notification: NotificationSummary;
      dataSources: NotificationDataSource[];
    }>;
    pageInfo: {
      hasNext: boolean;
      nextCursor?: string;
    };
  };
};
```

- BFFでは `validateWithZod(getApiNotificationsResponse, response.data, 'notifications API response')` を利用してランタイム検証を行う。
- Dashboard統計カードのウォッチ数取得は既存の `/api/data-sources` を継続利用するが、`perPage=1` で総件数のみ取得し通信量を抑える。

### データベース操作

- フロントエンドから直接DB操作は行わない。
- Backend既存の通知取得ユースケース（`notifications` / `notification_digest_entries` テーブル）を利用するのみ。

### アーキテクチャ設計

- **BFF層**: `server/api/notifications/index.get.ts` を新設し、クエリの正規化とレスポンス検証を担当。
- **ページ専用Composable**: `components/pages/dashboard/use-dashboard-page.ts` を新規作成し、データ取得・無限スクロール制御・統計値算出を担う。
- **UI層**: `NotificationList.vue` は通知カードのレイアウト、ローディング・エンプティ・エラー状態、アクティビティ種別ごとの表示を担当。IntersectionObserverを用いて下端のセンチネルを監視し、`hasNext` が true の場合に追加ロードをトリガー。
- **ViewModel整形**: `features/notifications/models/notification.ts` を追加し、APIレスポンスからUIで利用する型・整形ロジック（例：表示用日付フォーマット、各グループの最大5件スライス、アクティビティ種別→表示ラベル変換）を集約。

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/frontend/server/api/notifications/index.get.ts`**
   - Backend API呼び出し・クエリマッピング・Zodバリデーション・エラーハンドリングを実装。
2. **`packages/frontend/components/pages/dashboard/use-dashboard-page.ts`**
   - Dashboardページ専用Composable。データ取得、統計計算、無限スクロール制御をカプセル化。
3. **`packages/frontend/features/notifications/models/notification.ts`**
   - 通知一覧向けの型定義と整形ユーティリティ（エントリ上限、日付フォーマットなど）を提供。
4. **`packages/frontend/components/pages/dashboard/parts/NotificationList.vue`**
   - 通知リストUI本体。読み込み状態・エラー表示・センチネルによる追加ロードを含む。
5. **`packages/frontend/components/pages/dashboard/parts/__tests__/NotificationList.test.ts`**
   - グループ化・エンプティ・ロード中表示などのユニットテスト。

### 更新対象ファイル

1. **`packages/frontend/components/pages/dashboard/DashboardPage.vue`**
   - リポジトリ一覧の代わりに通知リストを組み込み、Composable経由でデータを受け取る構成へ変更。
2. **`packages/frontend/components/pages/dashboard/DashboardPage.stories.ts`**
   - 通知APIモックを使用したStoryに差し替え、代表的な状態（通常・空・ロード中・エラー）を網羅。
3. **`packages/frontend/components/pages/dashboard/DashboardPage.vrt.spec.ts`**
   - 画像スナップショット対象を通知リスト表示に合わせて更新。
4. **`packages/frontend/utils/validation.ts`（必要に応じて）**
   - バリデーション用の補助関数を通知用に拡張する場合のみ。
5. **`packages/frontend/generated/api/backend.ts` / `schemas` / `zod/chaseLightAPI.zod.ts` / `backend.msw.ts`**
   - Orval再生成により通知関連型とMSWハンドラーを取り込む（自動生成ファイル）。

## 5. テスト戦略

### Component Test（Presentation層）

- `NotificationList` の正常描画（未読通知あり）とアクティビティ種別ごとのグルーピング表示。
- 通知が空の場合のエンプティステート表示。
- APIエラー時に再読み込みアクション/メッセージが表示されること。
- `hasNext=true` の場合にセンチネル到達で追加読み込みコールバックが一度だけ発火すること（IntersectionObserverのモックを活用）。

### Unit Test（Service層）

- 今回は実装なし（ロジックはComposableとViewModelに集約し、Componentテストでカバー）。

### Unit Test（ViewModelユーティリティ）

- `mapNotificationDigest`（仮）で各グループごとにエントリを最大5件へスライスする挙動。
- 日付フォーマット関数がISO8601→`YYYY/MM/DD HH:mm` 形式へ変換すること。

### Storybook / VRT

- Storybook、VRTの確認はユーザーに依頼

## 6. 受け入れ基準

### 機能要件

- [ ] ダッシュボードに未読通知の一覧が表示され、初期表示で20件まで取得される。
- [ ] 通知カードにはデータソース名、通知発生日時（`sentAt ?? scheduledAt`）、アクティビティ種別ラベル、各種別ごと最大5件のタイトル・要約・発生日時・リンクが表示される。
- [ ] 画面下部までスクロールすると `hasNext` が true の間だけ自動で次ページが読み込まれる。
- [ ] 未読通知が0件のときは空状態メッセージが表示される。
- [ ] 未読通知数の統計カードが初期ロード済みの件数で更新される（リポジトリ統計は現状維持）。

### 非機能要件

- [ ] `pnpm format` と `pnpm lint` がエラーなく完了する。
- [ ] `pnpm --filter frontend test` が成功する。

### セキュリティ要件

- [ ] BFFルートで未認証アクセスに対して適切に401エラーを返す。
- [ ] BackendレスポンスをZodで検証し、不整形データは500/502として握り潰す。
- [ ] 外部リンク（GitHub等）を新しいタブで開き、クリックジャッキング対策として `rel="noopener noreferrer"` を付与する。

## 7. 実装手順

### Phase 1: APIクライアント整備とBFF実装

- 1-1. `pnpm --filter frontend generate:api` を実行し通知関連型を反映。
- 1-2. `server/api/notifications/index.get.ts` を実装し、クエリ正規化とZodバリデーション・エラーハンドリングを追加。
- 1-3. format, lint を実行し、フェーズ単位でコミット。

### Phase 2: DashboardページとComposable整備

- 2-1. `use-dashboard-page.ts` を実装し、通知・統計の取得と無限スクロール制御をComposable化。
- 2-2. `DashboardPage.vue` をComposable依存へ書き換え、通知リストコンポーネントを組み込む。
- 2-3. format, lint を実行しコミット。

### Phase 3: UIコンポーネント・テスト・Story更新

- 3-1. `NotificationList.vue` と関連ユーティリティ/テストを実装。
- 3-2. Storybook（MSWモック含む）を通知仕様に合わせて更新。Storybookのテストはここでは行わず、最後にユーザーに依頼する。
- 3-3. Vitestを実行し、format・lint後にコミット。

## 9. リスク・考慮事項

### 技術的リスク

- **Orval生成物の大規模差分**: 通知関連型追加で`generated/`配下に大きな差分が発生しレビューコストが上がる可能性。
- **IntersectionObserver依存**: ブラウザ互換性により無限スクロールが動作しないケース（サーバーレンダリングとの整合）。
- **通知件数の把握難**: Backendレスポンスに総未読件数が含まれないため、統計カードの値が「ロード済み件数」に留まる可能性。

### 軽減策

- Orval生成後は差分をコミットメッセージとともに明示し、生成コマンドの再現手順を記録する。
- IntersectionObserverはポリフィル不要なモダンブラウザを前提としつつ、非対応環境では「もっと見る」ボタンへのフォールバックを用意（センチネルが無効な場合に表示）。
- 未読件数の統計についてはUI上に注記を追加するか、今後Backend側で総件数を返す仕様追加を検討する旨をタスクに残す。
