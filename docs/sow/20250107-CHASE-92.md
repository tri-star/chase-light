# SOW: CHASE-92: フロントエンド用APIクライアントの作成(A)

## プロジェクト概要

**課題ID**: CHASE-92
**作成日**: 2025-01-07
**種別**: 新機能開発

## 1. 背景と目的

### 背景

backendのAPIを利用してフロントエンドの開発を行うために、packages/frontend内にbackendが提供するSwagger JSONを基にHTTPクライアント（型情報も含む）を生成する仕組みが必要。

現在はサンプルAPIとして`packages/frontend/server/api/github`が存在するが、これは本格的な開発には適さない。

### 目的

- backendのAPIを型安全に呼び出すためのクライアント生成
- フロントエンドAPIルート（BFF）での統一的なAPI呼び出し
- 開発効率向上とランタイムエラーの防止
- テスト・StoryBook時のモック環境整備

## 2. 実装スコープ

### 実装対象

- OrvalライブラリによるAPIクライアント自動生成
- Zodスキーマ生成による型安全性確保
- MSWモック生成によるテスト環境整備
- フロントエンドAPIルートでの生成クライアント利用
- ダッシュボードページでのAPI呼び出し実装
- 既存サンプルAPIの削除

### 利用ライブラリ

- **Orval**: OpenAPI仕様からAPIクライアント生成
- **Zod**: スキーマ検証とランタイム型安全性
- **MSW**: テスト・開発時のAPIモック

### 実装除外項目

- backendのSwagger JSON生成機能（既に実装済み）
- Auth0認証の実装（既に実装済み）
- 複雑なエラーハンドリング戦略（後続タスクで実装）

## 3. 技術仕様

### API仕様

#### Swagger JSON取得

- **URL**: `http://localhost:3001/doc`
- **形式**: OpenAPI 3.0仕様
- **対象API**: データソース関連API（GET /data-sources等）

#### 生成されるクライアント仕様

```typescript
// 生成されるクライアント例
export const getDataSources = (
  params?: GetDataSourcesParams,
  options?: RequestOptions
): Promise<DataSourceListResponse> => {
  return fetch('/data-sources', { ... })
}
```

### アーキテクチャ設計

BFF（Backend For Frontend）パターンを採用：

```
[Frontend Pages/Components]
         ↓ $fetch / useFetch
[Frontend API Routes (/api)]  ← BFF層（Orval生成クライアント利用）
         ↓ 生成されたクライアント
[Backend API]
         ↓
[Database]
```

- **BFF層の責務**: 認証統合、データ変換、エラーハンドリング、スキーマ検証
- **生成クライアントの責務**: 型安全なHTTP通信、リクエスト/レスポンスの型定義

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/frontend/orval.config.js`**
   - Orval設定ファイル
   - Swagger JSON取得先、出力先、クライアント設定

2. **`packages/frontend/generated/api/`**
   - 自動生成されるAPIクライアント
   - Zodスキーマ
   - MSWモック

3. **`packages/frontend/server/api/data-sources/index.ts`**
   - データソース一覧取得BFF API
   - 生成クライアントを利用

### 更新対象ファイル

1. **`packages/frontend/package.json`**
   - Orvalライブラリ追加
   - APIクライアント生成コマンド追加
   - 関連依存関係追加

2. **`packages/frontend/pages/dashboard.vue`**
   - 生成されたAPIクライアント経由でのデータ取得
   - 既存サンプルAPI呼び出しの削除

3. **既存のテストファイル**
   - サンプルAPI削除に伴うテスト修正

### 削除対象ファイル

1. **`packages/frontend/server/api/github/`**
   - `user.get.ts`
   - `repos.get.ts`
   - サンプル実装のため完全削除

## 5. テスト戦略

### Component Test（Frontend API Routes層）

- BFF APIの正常な応答確認
- 認証エラー時の適切な応答確認
- 生成クライアントとの統合確認

### Unit Test（生成クライアント）

- 生成されたクライアント関数のモック利用テスト
- スキーマ検証の動作確認
- MSWモックとの連携テスト

### Feature Test（Pages）

- ダッシュボードページでのAPI呼び出し確認
- エラーハンドリングの確認
- ローディング状態の確認

## 6. 受け入れ基準

### 機能要件

- [ ] Orval設定によりbackend Swagger JSONからクライアント生成成功
- [ ] 生成されたクライアントがfetch ベースで動作
- [ ] Zodスキーマが生成され、ランタイム検証が動作
- [ ] MSWモックが生成され、テスト・Storybook で利用可能
- [ ] ダッシュボードページでデータソース一覧API呼び出し成功
- [ ] 既存サンプルAPI（`/api/github`）が完全削除
- [ ] package.json にクライアント生成コマンド追加

### 非機能要件

- [ ] 既存のテストが全て通る
- [ ] 型エラーが発生しない
- [ ] ビルドが成功する
- [ ] リンターエラーが発生しない

### セキュリティ要件

- [ ] BFF層でのセッション認証が正常に動作
- [ ] 生成クライアントでAuth0トークンが適切に送信される
- [ ] クロスサイトリクエスト対策が維持される

## 7. 実装手順

### Phase 1: Orval環境構築

- 1-1. Orvalライブラリのインストール
- 1-2. orval.config.jsの作成と設定
- 1-3. package.jsonへの生成コマンド追加
- 1-4. 初回クライアント生成テスト

### Phase 2: BFF API実装

- 2-1. データソース一覧取得BFF APIの実装
- 2-2. 生成クライアントとの統合
- 2-3. エラーハンドリングの実装
- 2-4. スキーマ検証の実装

### Phase 3: フロントエンド統合

- 3-1. ダッシュボードページのAPI呼び出し実装
- 3-2. ローディング・エラー状態の実装
- 3-3. 既存サンプルAPIの削除
- 3-4. テスト修正と動作確認

### Phase 4: テスト・品質確認

- 4-1. MSWモックのセットアップ
- 4-2. Componentテストの作成・実行
- 4-3. 全体的なテスト実行と品質確認
- 4-4. ドキュメント更新

## 8. Orval設定詳細

### 基本設定

```javascript
module.exports = {
  backend: {
    input: 'http://localhost:3001/doc',
    output: {
      target: './generated/api/backend.ts',
      client: 'fetch',
      schemas: './generated/api/schemas',
    },
    hooks: {
      afterAllFilesWrite: 'prettier --write',
    },
  },
}
```

### Zod統合設定

```javascript
output: {
  mode: 'split',
  target: './generated/api',
  schemas: './generated/api/schemas',
  client: 'zod',
}
```

## 9. リスク・考慮事項

### 技術的リスク

- **Swagger JSON取得失敗**: backend開発サーバーが起動していない場合の生成失敗
- **型定義の複雑性**: 複雑なレスポンス構造での型生成エラー
- **MSW統合**: モック生成時の型不整合

### 軽減策

- 開発環境での明確なセットアップ手順書作成
- 段階的な実装による早期問題発見
- CI/CDでの自動生成・テスト実行
- fallback用の型定義準備

### 今後の拡張計画

- 他のbackend APIエンドポイントへの対応拡大
- リアルタイム通信（WebSocket）との統合検討
- パフォーマンス最適化（キャッシング戦略）