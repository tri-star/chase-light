# SOW: CHASE-122: アクティビティからNotification一覧を生成する仕組みの実装

## プロジェクト概要

**課題ID**: CHASE-122
**作成日**: 2025-10-16
**種別**: 新機能開発

## 1. 背景と目的

### 背景

現在、GitHubリポジトリのアクティビティ（リリース、PR、Issue）を検知してDBに保存する仕組みは実装済み（`detection`フィーチャー）ですが、ユーザーへの通知を行うための中間データが存在していません。

ユーザーがウォッチしているデータソースで新しいアクティビティが発生した際、ユーザーにダイジェスト通知を送る必要がありますが、その前段階として「誰に、いつ、何を通知するか」を管理するNotificationレコードを生成する仕組みが必要です。

### 目的

- アクティビティ情報から購読ユーザーを解決し、ユーザーごとのNotificationレコードを生成するバッチ処理を実装する
- 通知の実送信は別課題とし、本課題では通知候補データの作成までを対象とする
- ユーザーの通知設定（ダイジェスト通知時刻）を考慮し、適切な`scheduled_at`を計算してNotificationに設定する

## 2. 実装スコープ

### 実装対象

- `packages/backend/src/features/notification` フィーチャー配下に通知生成機能を実装
- 未処理のActivityを検索し、購読ユーザーを解決してNotificationレコードを作成するLambda関数
- ユーザーの通知設定から次の通知時刻（`scheduled_at`）を計算するロジック
- DBスキーマの拡張（`notifications`テーブルに`scheduled_at`と`status`を追加、`user_preferences`テーブルに通知時刻設定を追加）

### 機能要件

1. **購読ユーザーの解決**
   - Activityが所属するDataSourceを購読しているユーザー一覧を取得
   - `user_watches`テーブルから`notification_enabled=true`かつ該当のアクティビティタイプを監視しているユーザーを抽出

2. **Notification生成**
   - ユーザーごとに`(user_id, activity_id)`の組み合わせでNotificationレコードを作成
   - 既存レコードがある場合はUPSERT（重複防止）
     - **重要**: UPSERT時、既に`status='sent'`または`status='failed'`のレコードは更新しない
     - `status='pending'`のレコードのみ更新対象とする（scheduled_atの再計算など）
     - ON CONFLICT時の更新条件: `WHERE notifications.status = 'pending'`
   - `status`は初期値として`pending`を設定
   - `scheduled_at`はユーザーの通知設定から計算

3. **通知時刻の計算**
   - ユーザーが設定したダイジェスト通知時刻（例: ["18:00", "18:30"]）から、現在時刻より後の最も近い時刻を選択
   - 該当する時刻が今日中にない場合は翌日の最初の時刻を選択
   - ユーザーのタイムゾーンを考慮

4. **バッチ実行**
   - EventBridge/StepFunctionsから定期的に呼び出されるLambda関数として実装
   - まだNotificationを作成していないActivityを効率的に特定

### 実装除外項目

- 通知の実送信処理（メール/Slack/API呼び出し等）
- 定時Lambda からの集計・送信機能
- ユーザーがダイジェスト通知時刻を設定するUIの実装
- 通知のフィルタリング機能（ユーザーが自然言語で興味のある変更を指定する機能）

## 3. 技術仕様

### データベーススキーマ変更

**マイグレーション方針**:
- `packages/backend/src/db/schema.ts`を更新し、Drizzle Kitで自動生成する
- 以下のSQLは参考情報として記載（実際はDrizzle Kitが生成）

#### notificationsテーブルの拡張

既存の`notifications`テーブルに以下のカラムを追加：

```sql
-- 参考: 以下はDrizzle Kitで自動生成されるSQLの例
ALTER TABLE notifications
ADD COLUMN scheduled_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN status TEXT NOT NULL DEFAULT 'pending';

-- インデックス追加
CREATE INDEX idx_notifications_status ON notifications(status);
CREATE INDEX idx_notifications_scheduled_at ON notifications(scheduled_at);
CREATE INDEX idx_notifications_status_scheduled ON notifications(status, scheduled_at);
```

**カラム説明**：

- `scheduled_at`: ダイジェスト通知の予定送信時刻
- `status`: 通知の状態（'pending' | 'sent' | 'failed'）

既存の`sent_at`は実際に送信された時刻を記録するために残します。

#### user_preferencesテーブルの拡張

ユーザーのダイジェスト通知設定を追加：

```sql
ALTER TABLE user_preferences
ADD COLUMN digest_notification_times TEXT[] DEFAULT ARRAY['18:00'];
```

**カラム説明**：

- `digest_notification_times`: 通知時刻のリスト（例: ['18:00', '18:30']）
- HH:MM形式の文字列配列
- デフォルトは18:00（JST）

#### activitiesテーブルの参照

既存の`activities`テーブルの`status`カラムを活用：

- `status='completed'`: 翻訳処理などが完了し、通知可能な状態
- `status='pending'`: まだ処理中
- Notification生成対象は`status='completed'`かつまだNotificationが作成されていないActivity

### アーキテクチャ設計

`detection`フィーチャーと同様のレイヤード構成を採用：

```
packages/backend/src/features/notification/
├── domain/
│   ├── notification.ts                      # Notificationエンティティ
│   ├── recipient.ts                         # Recipient（Userの通知用表現）
│   ├── notification-schedule.ts             # 通知スケジュール計算
│   └── repositories/
│       ├── notification.repository.ts       # Notificationリポジトリポート
│       ├── recipient.repository.ts          # Recipientリポジトリポート
│       └── activity-subscriber.repository.ts # 購読ユーザー取得ポート
├── application/
│   └── use-cases/
│       └── create-notifications.use-case.ts # Notification生成ユースケース
├── infra/
│   └── repositories/
│       ├── drizzle-notification.repository.ts
│       ├── drizzle-recipient.repository.ts
│       └── drizzle-activity-subscriber.repository.ts
├── workers/
│   └── create-notifications/
│       ├── handler.ts                       # Lambda関数ハンドラー
│       ├── index.ts                         # エントリポイント
│       └── __tests__/handler.test.ts        # Component Test
├── constants/
│   └── notification.constants.ts
└── index.ts                                  # 外部公開API
```

**レイヤーの責務**：

- **Domain層**:
  - `Notification`: 通知の基本情報（id, userId, activityId, scheduledAt, status など）
  - `Recipient`: ユーザーの通知用表現（id, email, name, timezone, digestNotificationTimes）
  - `NotificationSchedule`: 通知時刻計算のドメインロジック
  - `Brand`型で`NotificationId`, `UserId`, `ActivityId`を表現

- **Application層**:
  - `CreateNotificationsUseCase`: 未処理Activityから購読ユーザーを解決し、Notificationを生成

- **Infra層**:
  - `DrizzleNotificationRepository`: notificationsテーブルへのアクセス
  - `DrizzleRecipientRepository`: usersとuser_preferencesテーブルへのアクセス
  - `DrizzleActivitySubscriberRepository`: activitiesとuser_watchesテーブルへのアクセス

- **Workers層**:
  - `create-notifications/handler.ts`: Lambda関数のエントリポイント

### ユースケース詳細

#### CreateNotificationsUseCase

**入力**:

```typescript
type CreateNotificationsInput = {
  activityIds?: string[]; // 省略時は未処理のActivityを取得
  limit?: number; // 一度に処理するActivity数の上限（デフォルト: 100）
};
```

**出力**:

```typescript
type CreateNotificationsOutput = {
  notificationIds: string[];
  processedActivityCount: number;
  skippedActivityCount: number; // 購読ユーザーがいないなどでスキップされたActivity数
};
```

**処理フロー**:

1. **未処理Activity一覧の取得**
   - `activityIds`が指定されている場合: 指定されたActivityを取得
   - 指定されていない場合: `status='completed'`でまだNotificationが作成されていないActivityを取得（limitまで）

2. **各Activityに対する処理**
   - a. Activityが所属するDataSourceを取得
   - b. DataSourceを購読しているユーザー一覧を取得（`user_watches`から、`notification_enabled=true`かつ該当のactivityTypeを監視しているユーザー）
   - c. 購読ユーザーがいない場合はスキップ

3. **各ユーザーに対するNotification生成**
   - ユーザーの通知設定（`digest_notification_times`とtimezone）を取得
   - 次の通知時刻を計算
   - Notificationレコードを作成（UPSERT）
     - `user_id`, `activity_id`, `title`, `message`, `notification_type`, `scheduled_at`, `status='pending'`, `is_read=false`

4. **作成結果の集計**
   - 作成したNotificationのID一覧を返す
   - 処理したActivityの数、スキップしたActivityの数を返す

### 通知時刻計算ロジック

`domain/notification-schedule.ts`に実装：

```typescript
/**
 * ユーザーの設定と現在時刻から次の通知時刻を計算
 *
 * @param digestTimes - ユーザーが設定した通知時刻のリスト（例: ["18:00", "18:30"]）
 * @param timezone - ユーザーのタイムゾーン（例: "Asia/Tokyo"）
 * @param currentTime - 現在時刻（テストのため引数化）
 * @returns 次の通知時刻
 */
function calculateNextNotificationTime(
  digestTimes: string[],
  timezone: string,
  currentTime: Date = new Date(),
): Date;
```

**計算ルール**:

1. 現在時刻をユーザーのタイムゾーンに変換
2. 今日の通知時刻リストを生成（例: ["18:00", "18:30"] → [今日18:00, 今日18:30]）
3. 現在時刻より後の最初の時刻を選択
4. なければ翌日の最初の時刻を選択

**例**:

- 現在時刻: 17:30 JST, 設定: ["18:00", "18:30"] → scheduled_at: 今日 18:00 JST
- 現在時刻: 18:15 JST, 設定: ["18:00", "18:30"] → scheduled_at: 今日 18:30 JST
- 現在時刻: 19:00 JST, 設定: ["18:00", "18:30"] → scheduled_at: 翌日 18:00 JST
- 現在時刻: 23:50 JST, 設定: ["00:10"] → scheduled_at: 翌日 00:10 JST

### Lambda関数仕様

#### create-notifications

**トリガー**: EventBridge Schedule（定期実行、例: 10分ごと）

**入力**:

```typescript
{
  // 通常は空
}
```

**出力**:

```typescript
{
  notificationIds: string[]
  processedActivityCount: number
  skippedActivityCount: number
}
```

**環境変数**:

- `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`: データベース接続情報
- `USE_AWS`: AWS環境フラグ
- `STAGE`: 環境識別子（dev, staging, prod）

**タイムアウト**: 300秒

**実装ポイント**:

- `TransactionManager.transaction()`でトランザクション管理
- リポジトリとユースケースをハンドラー内で初期化
- エラーはログ出力後に再スロー（StepFunctionsでのエラーハンドリング用）

## 4. 実装ファイル一覧

### DBスキーマ更新

1. **`packages/backend/src/db/schema.ts`**
   - `notifications`テーブルに`scheduledAt`と`status`カラムを追加
   - `user_preferences`テーブルに`digestNotificationTimes`カラムを追加
   - 適切なインデックスを定義

2. **`packages/backend/drizzle/migrations/XXXX_add_notification_scheduling.sql`**
   - Drizzle Kitで自動生成されるマイグレーションファイル

### 新規作成ファイル

#### Domain層

1. **`packages/backend/src/features/notification/domain/notification.ts`**
   - Notificationエンティティ型定義
   - NotificationId, NotificationStatus の型定義
   - toNotificationId(), toActivityId() などのブランド化関数

2. **`packages/backend/src/features/notification/domain/recipient.ts`**
   - Recipient（User の通知用表現）エンティティ型定義
   - UserId の型定義
   - toUserId() ブランド化関数

3. **`packages/backend/src/features/notification/domain/notification-schedule.ts`**
   - calculateNextNotificationTime() 関数
   - 通知時刻計算のドメインロジック

4. **`packages/backend/src/features/notification/domain/repositories/notification.repository.ts`**
   - NotificationRepository インターフェース定義
   - upsertNotification(), upsertMany(), findByUserAndActivity() メソッド定義

5. **`packages/backend/src/features/notification/domain/repositories/recipient.repository.ts`**
   - RecipientRepository インターフェース定義
   - findById(), findMany() メソッド定義

6. **`packages/backend/src/features/notification/domain/repositories/activity-subscriber.repository.ts`**
   - ActivitySubscriberRepository インターフェース定義
   - findSubscribersByDataSource(), findUnprocessedActivities() メソッド定義

#### Application層

7. **`packages/backend/src/features/notification/application/use-cases/create-notifications.use-case.ts`**
   - CreateNotificationsUseCase クラス
   - createNotifications() メソッド実装

#### Infra層

8. **`packages/backend/src/features/notification/infra/repositories/drizzle-notification.repository.ts`**
   - DrizzleNotificationRepository クラス
   - notificationsテーブルへのCRUD操作実装
   - UPSERT処理（ON CONFLICT句を使用）

9. **`packages/backend/src/features/notification/infra/repositories/drizzle-recipient.repository.ts`**
   - DrizzleRecipientRepository クラス
   - usersとuser_preferencesテーブルをJOINして取得

10. **`packages/backend/src/features/notification/infra/repositories/drizzle-activity-subscriber.repository.ts`**
    - DrizzleActivitySubscriberRepository クラス
    - activitiesとuser_watchesテーブルをJOINして購読ユーザーを取得
    - 未処理Activity取得のクエリ実装

#### Workers層

11. **`packages/backend/src/features/notification/workers/create-notifications/handler.ts`**
    - Lambda関数ハンドラー実装
    - DB接続、トランザクション管理、ユースケース初期化

12. **`packages/backend/src/features/notification/workers/create-notifications/index.ts`**
    - Lambda関数エントリポイント（handler をエクスポート）

13. **`packages/backend/src/features/notification/workers/create-notifications/__tests__/handler.test.ts`**
    - Component Test実装

#### Constants

14. **`packages/backend/src/features/notification/constants/notification.constants.ts`**
    - NOTIFICATION_STATUS: 通知ステータスの定数
    - NOTIFICATION_TYPE: 通知タイプの定数
    - NOTIFICATION_DEFAULTS: デフォルト値（処理上限数、デフォルト通知時刻など）
    - NOTIFICATION_ERRORS: エラーメッセージ

#### Index

15. **`packages/backend/src/features/notification/index.ts`**
    - 外部公開APIのまとめ（必要に応じてユースケースやアダプタを公開）

### 更新対象ファイル

1. **`packages/backend/scripts/lambda-config.mjs`**
   - `create-notifications` Lambda関数の設定を追加

2. **`packages/backend/infrastructure/sam-template.yaml`**
   - `CreateNotificationsFunction` リソースを追加
   - EventBridge Ruleで定期実行の設定（例: cron(0/10 \* \* _ ? _)で10分ごと）

## 5. テスト戦略

### Component Test（Workers層）

**テストファイル**: `packages/backend/src/features/notification/workers/create-notifications/__tests__/handler.test.ts`

**テストケース**:

1. **正常系: 購読ユーザーに対してNotificationが作成される**
   - 前提: Activityが1件、そのDataSourceを購読しているユーザーが2人存在
   - 実行: ハンドラーを呼び出し
   - 期待: 2件のNotificationレコードが作成される
   - 検証: notificationsテーブルに2件のレコードが存在し、user_id, activity_id, scheduled_at, status='pending'が正しく設定されている

2. **購読していないユーザーにはNotificationが作成されない**
   - 前提: Activityが1件、そのDataSourceを購読していないユーザーが1人存在
   - 実行: ハンドラーを呼び出し
   - 期待: Notificationレコードが作成されない（skippedActivityCount=1）

3. **同一(user_id, activity_id)に対して重複レコードが作成されない**
   - 前提: 既に(user_id=U1, activity_id=A1)のNotificationレコードが存在
   - 実行: 同じActivityに対してハンドラーを再度呼び出し
   - 期待: 新規レコードは作成されず、既存レコードが更新される（UPSERT）
   - 検証: notificationsテーブルのレコード数が増えていない、updated_atが更新されている

4. **ユーザーの通知設定から適切なscheduled_atが計算される**
   - 前提:
     - 現在時刻: 2025-10-16 17:30 JST
     - ユーザーA: digest_notification_times=["18:00", "18:30"], timezone="Asia/Tokyo"
     - ユーザーB: digest_notification_times=["19:00"], timezone="Asia/Tokyo"
     - Activityが1件
   - 実行: ハンドラーを呼び出し
   - 期待:
     - ユーザーAのNotification: scheduled_at=2025-10-16 18:00 JST
     - ユーザーBのNotification: scheduled_at=2025-10-16 19:00 JST

5. **複数のユーザー設定パターンに対応**
   - 前提:
     - ユーザーC: digest_notification_times=["18:00"], timezone="America/New_York"
     - ユーザーD: digest_notification_times=[] (空配列) → デフォルト時刻を使用
     - Activityが1件
   - 実行: ハンドラーを呼び出し
   - 期待:
     - ユーザーCのNotification: scheduled_atがNYタイムゾーンで正しく計算されている
     - ユーザーDのNotification: scheduled_atがデフォルト時刻（18:00 JST）で設定されている

6. **未処理Activityのみが対象になる**
   - 前提: Activity A1（status='completed'、Notification未作成）、Activity A2（status='pending'）
   - 実行: ハンドラーを呼び出し
   - 期待: A1に対してのみNotificationが作成される（A2はスキップ）

7. **処理上限数が機能する**
   - 前提: 未処理Activityが200件、limit=100
   - 実行: ハンドラーを呼び出し
   - 期待: 100件のActivityに対してNotificationが作成される

### Unit Test（Domain層）

**テストファイル**: `packages/backend/src/features/notification/domain/__tests__/notification-schedule.test.ts`

**テストケース**:

1. **通知時刻計算: 今日の次の時刻を選択**
   - 入力: digestTimes=["18:00", "18:30"], timezone="Asia/Tokyo", currentTime=2025-10-16 17:30 JST
   - 期待: 2025-10-16 18:00 JST

2. **通知時刻計算: 今日の最後の時刻も過ぎている場合は翌日の最初の時刻**
   - 入力: digestTimes=["18:00", "18:30"], timezone="Asia/Tokyo", currentTime=2025-10-16 19:00 JST
   - 期待: 2025-10-17 18:00 JST

3. **通知時刻計算: 深夜0時跨ぎのケース**
   - 入力: digestTimes=["00:10", "06:00"], timezone="Asia/Tokyo", currentTime=2025-10-16 23:50 JST
   - 期待: 2025-10-17 00:10 JST

4. **通知時刻計算: タイムゾーンが異なる場合**
   - 入力: digestTimes=["18:00"], timezone="America/New_York", currentTime=2025-10-16 17:00 EST
   - 期待: 2025-10-16 18:00 EST（UTC換算で正しいこと）

5. **通知時刻計算: 設定が空の場合はデフォルト時刻**
   - 入力: digestTimes=[], timezone="Asia/Tokyo", currentTime=2025-10-16 17:30 JST
   - 期待: デフォルト時刻（例: 今日 18:00 JST）を使用

## 6. 受け入れ基準

### 機能要件

- [ ] 購読しているDataSourceのActivityに対してNotificationが作成される
- [ ] 購読していないユーザーにはNotificationが作成されない
- [ ] 同一(user_id, activity_id)に対して重複レコードが作成されない（UPSERT動作）
- [ ] ユーザーの通知設定（digest_notification_times）から適切なscheduled_atが計算される
- [ ] 複数の通知時刻設定に対応（例: ["18:00", "18:30"]）
- [ ] ユーザーのタイムゾーンを考慮した時刻計算が行われる
- [ ] status='completed'のActivityのみが処理対象となる
- [ ] 処理上限数（limit）が機能する

### 非機能要件

- [ ] 既存のテストが全て通る
- [ ] DBマイグレーションが正常に実行できる
- [ ] Lambda関数が300秒以内に処理を完了する
- [ ] トランザクション処理でデータ整合性が保たれる
- [ ] エラー時には適切なログが出力される

### セキュリティ要件

- [ ] ユーザー情報（Recipient）への不正アクセスがない
- [ ] 購読していないユーザーの情報が漏洩しない

## 7. 実装手順

**重要**: 各フェーズ完了後にコミットを行い、全フェーズ完了後にpushとPR作成を行ってください。

### Phase 1: DBスキーマ更新とマイグレーション

- 1-1. `packages/backend/src/db/schema.ts`の更新
  - `notifications`テーブルに`scheduledAt`と`status`カラムを追加
  - `user_preferences`テーブルに`digestNotificationTimes`カラムを追加
  - インデックスの追加
- 1-2. Drizzle Kitでマイグレーションファイルを生成（`pnpm --filter backend db:generate`）
- 1-3. マイグレーションファイルの内容確認
- 1-4. マイグレーション実行（`pnpm --filter backend db:migrate`）
- 1-5. スキーマ変更の動作確認
- 1-6. **Phase 1完了後、コミット**

### Phase 2: Domain層の実装

- 2-1. `notification.ts` の実装（Notificationエンティティ型定義）
- 2-2. `recipient.ts` の実装（Recipientエンティティ型定義）
- 2-3. `notification-schedule.ts` の実装（通知時刻計算ロジック）
- 2-4. `notification-schedule.test.ts` の作成・実行（Unit Test）
- 2-5. `domain/repositories/` 配下のポートインターフェース定義
  - `notification.repository.ts`
  - `recipient.repository.ts`
  - `activity-subscriber.repository.ts`
- 2-6. **Phase 2完了後、コミット**

### Phase 3: Infra層の実装

- 3-1. `drizzle-notification.repository.ts` の実装
  - UPSERT処理の実装（ON CONFLICT句、status='pending'のみ更新）
- 3-2. `drizzle-recipient.repository.ts` の実装
  - users と user_preferences のJOIN
- 3-3. `drizzle-activity-subscriber.repository.ts` の実装
  - 購読ユーザー取得のクエリ
  - 未処理Activity取得のクエリ
- 3-4. Infra層の実装完了後、コミット

### Phase 4: Application層の実装

- 4-1. `constants/notification.constants.ts` の作成
- 4-2. `create-notifications.use-case.ts` の実装
  - 未処理Activity取得
  - 購読ユーザー解決
  - Notification生成ロジック
  - 通知時刻計算の呼び出し
- 4-3. ユースケースのロジック確認（必要に応じてUnit Test追加）
- 4-4. **Phase 4完了後、コミット**

### Phase 5: Workers層の実装

- 5-1. `workers/create-notifications/handler.ts` の実装
  - DB接続、トランザクション管理
  - ユースケースの初期化と呼び出し
  - エラーハンドリング
- 5-2. `workers/create-notifications/index.ts` の作成
- 5-3. `workers/create-notifications/__tests__/handler.test.ts` の作成・実行（Component Test）
- 5-4. **Phase 5完了後、コミット**

### Phase 6: Lambda設定とデプロイ準備

- 6-1. `scripts/lambda-config.mjs` に`create-notifications`を追加
- 6-2. `infrastructure/sam-template.yaml` に`CreateNotificationsFunction`を追加
- 6-3. Lambda関数のビルド確認（`pnpm --filter backend build-lambda`）
- 6-4. ローカル環境でのテスト実行（SAM Local）
- 6-5. **Phase 6完了後、コミット**

### Phase 7: 統合テストと最終確認

- 7-1. 全テストの実行（`pnpm --filter backend test`）
- 7-2. Lint・Formatの実行（`pnpm --filter backend lint`, `pnpm --filter backend format`）
- 7-3. 型チェックの実行（`pnpm --filter backend lint:type`）
- 7-4. 受け入れ基準の確認
- 7-5. **最終コミット**
- 7-6. **リモートにpush**
- 7-7. **PR作成**

## 8. リスク・考慮事項

### 技術的リスク

- **同時実行時の競合状態**: 複数のLambda関数が同時に実行された場合、同じActivityに対して重複したNotificationが作成される可能性
  - **軽減策**: UPSERT処理（ON CONFLICT）により、同一(user_id, activity_id)に対しては既存レコードが更新されるため、重複は発生しない

- **大量Activity処理時のタイムアウト**: 一度に大量のActivityを処理する場合、Lambda関数がタイムアウトする可能性
  - **軽減策**: 処理上限数（limit）を設定し、段階的に処理する。Lambda関数のタイムアウトを300秒に設定

- **タイムゾーン計算の複雑性**: ユーザーごとに異なるタイムゾーンを考慮した時刻計算が複雑
  - **軽減策**: Domain層で通知時刻計算ロジックを独立させ、Unit Testで徹底的に検証

- **データ整合性**: activitiesテーブルとnotificationsテーブル間の整合性
  - **軽減策**: トランザクション処理により一貫性を確保。外部キー制約により参照整合性を保証

### 運用上の考慮事項

- **通知設定のデフォルト値**: 新規ユーザーのdigest_notification_timesが未設定の場合の動作
  - **対応**: DBスキーマでデフォルト値を設定（['18:00']）、アプリケーション側でも空配列の場合はデフォルト値を使用

- **通知時刻の重複**: 同じユーザーが複数のActivityに対して同じscheduled_atを持つNotificationを持つ場合
  - **影響**: 通知送信側（別課題）でダイジェストとしてまとめて送信することで対応

- **Activity処理の順序**: どのActivityから処理するか（FIFO、優先度など）
  - **初期実装**: created_at順（古い順）で処理。将来的に優先度を導入する可能性

### モニタリング・運用

- CloudWatch Logsでエラーログを監視
- Lambda関数の実行時間、エラー率をCloudWatch Metricsで監視
- 未処理Activityの滞留状況をモニタリング（将来的にカスタムメトリクス化）

## 9. 今後の拡張計画

- 通知のフィルタリング機能（ユーザーが自然言語で興味のある変更を指定）
- 通知の優先度設定
- 複数チャンネル対応（メール、Slack、WebPush など）
- ユーザーが通知設定をUI上で変更できる機能
- ダイジェスト通知の実送信機能（別課題）
