# SOW: CHASE-122: アクティビティ通知生成バッチの実装

## プロジェクト概要

**課題ID**: CHASE-122  
**作成日**: 2025-10-16  
**種別**: 機能追加

## 1. 背景と目的

### 背景

- `features/detection` でデータソースのアクティビティを取り込み `activities` テーブルへ保存する仕組みは稼働しているが、購読ユーザー向けの `notifications` レコードは生成されていない。
- 将来実装予定の「定時配信Lambda」は `notifications` テーブルを参照して送信対象を決定する前提で設計されており、現状では必要なデータが存在しない。
- ユーザーはデータソースをウォッチし、通知有効／種別フィルタ（リリース・Issue・PR）を設定できるが、スケジュールやタイムゾーンに基づいたダイジェスト生成ロジックが未整備である。

### 目的

- アクティビティ発生後に購読ユーザー単位で通知候補を `notifications` テーブルへ生成するバッチ（Lambdaワーカー）を実装し、後続の送信処理が利用できるデータソースを整備する。
- 通知スケジュール（例: 18:00/18:30 のような30分刻み）とユーザーのタイムゾーンを考慮した `scheduled_at` を計算し、重複を排除したうえで記録する。
- `features/notification` をドメイン〜アプリケーション〜インフラ構造で整備し、今後の送信処理やチャネル拡張（Slack等）を見据えた土台を用意する。

## 2. 実装スコープ

### 実装対象

- `features/notification` フィーチャーに以下を実装
  - 通知ドメインモデル（通知ステータス、配信メタ情報、Recipient表現）
  - アクティビティ×購読者の抽出リポジトリ
  - スケジュール計算サービス & 通知生成ユースケース
  - EventBridge起動を前提とした Lambda ハンドラー (`generate-digest-notifications`)
- `notifications` テーブル拡張と `user_preferences` テーブルへのダイジェスト設定追加
- Lambda ビルド設定（`scripts/lambda-config.mjs`）と SAM テンプレートの更新（EventBridge 30分毎トリガーを想定）
- 関連ドキュメント（DB設計／SOW ディレクトリ）更新

### 更新可能な項目

1. `packages/backend/src/db/schema.ts`, `src/db/migrations/**`, `src/db/factories.ts`
2. `packages/backend/src/features/notification/**`（ドメイン・アプリケーション・インフラ・ワーカー・テスト）
3. `packages/backend/scripts/lambda-config.mjs`, `scripts/build-lambda.mjs`, `infrastructure/sam-template.yaml`, `infrastructure/events/notification/*.json`
4. `package.json`, `pnpm-lock.yaml`（タイムゾーン計算用に `luxon` を追加）
5. ドキュメント更新（`docs/database-schema-design.md`, `docs/project-overview.md` への追記が必要な場合を含む）

### 実装除外項目

- 通知の実送信（メール/Slack/API 呼び出し）ロジック
- フロントエンド UI や API からの即時通知機能追加
- StepFunctions での並列ファンアウト実装（Map State 等）は将来課題
- ユーザーによる通知スケジュール設定UI・API（今回はDB項目だけを追加）

## 3. 技術仕様

### ワーカー仕様（Lambda）

- **エントリポイント**: `src/features/notification/workers/generate-digest-notifications/handler.ts`
- **呼び出し方**: EventBridge 30分間隔（Cron: `cron(0/30 * * * ? *)`）で起動 / 手動実行
- **入力イベント**

```jsonc
{
  "limit": 200, // 1回の実行で処理する (activity, user) ペア数の上限（省略時 200）
  "activityIds": ["UUID"], // 任意。指定時は該当アクティビティのみ処理
  "dryRun": false, // true の場合はDBへ書き込まずログ出力のみ
}
```

- **処理フロー**
  1. `TransactionManager.transaction` 内で実行。必要に応じてバッチサイズやタイムアウトを制御。
  2. `NotificationPreparationRepository` が `activities`・`data_sources`・`user_watches`・`users`・`user_preferences` を結合し、「まだ通知が作られていない (activity, user) ペア」を抽出 (`notifications` との `NOT EXISTS`)。
     - `user_watches.notificationEnabled = true`
     - アクティビティ種別ごとに `watchReleases/watchIssues/watchPullRequests` を判定
     - `activities.status` は `completed` のみ対象（翻訳等が完了したデータを通知）
  3. `NotificationScheduleService` がユーザーのダイジェスト設定（30分刻みの `HH:mm` 配列）とタイムゾーンから次回 `scheduled_at` を計算。
     - 参照時刻は `max(activity.createdAt, now)`
     - 当日残りのスロットが無ければ翌日最初のスロットへロールオーバー
     - タイムゾーン計算は `luxon` を使用。設定が無い場合は `users.timezone`、更に無い場合は `Asia/Tokyo`（JST）と `DEFAULT_DIGEST_SLOTS = ["18:00"]` を使用
  4. `NotificationRepository` が `notifications` へ挿入を行い、重複時は `ON CONFLICT DO NOTHING` で既存レコードを保持する（`(user_id, activity_id)` のユニーク制約）。
     - 追加項目: `status = 'pending'`, `scheduled_at`, `metadata` にアクティビティ要約/スケジュール情報をJSONで格納
  5. 作成件数/スキップ件数をログ & ハンドラー戻り値で返却

- **戻り値**

```jsonc
{
  "created": 150,
  "skippedByConflict": 12,
  "totalExamined": 162,
  "lastProcessedActivityId": "UUID | null",
}
```

### ドメイン仕様

- `NotificationStatus`: `pending | queued | sent | failed | cancelled`
- `NotificationType`: 既存 `notificationType` カラムは `activity_digest` をデフォルトとして利用
- `Recipient` ドメイン: `id`, `timezone`, `digestTimes`, `channels`（現状は `"digest"` のみ）を保持
- `NotificationDraft`: `activityId`, `userId`, `scheduledAt`, `status`, `metadata`
- `metadata` 例（JSON）

```json
{
  "activityType": "release",
  "dataSourceId": "UUID",
  "dataSourceName": "owner/repo",
  "scheduledSlot": "18:30",
  "digestTimezone": "Asia/Tokyo"
}
```

### データベース操作

- マイグレーションは Drizzle Kit で `schema.ts` の定義変更から自動生成し、手書きSQLは追加しない。

- **`notifications` テーブル**
  - 新規追加カラム
    - `scheduled_at TIMESTAMPTZ NOT NULL DEFAULT now()`
    - `status TEXT NOT NULL DEFAULT 'pending'`
    - `status_detail TEXT NULL`
    - `metadata JSONB NULL`
  - 既存データに対し `scheduled_at = COALESCE(sent_at, created_at, NOW())` をマイグレーションで補正
  - `(user_id, activity_id)` にユニーク制約追加 (`notifications_user_activity_unique`)
  - 新規インデックス
    - `idx_notifications_scheduled_at` (scheduled_at)
    - `idx_notifications_status` (status)
- **`user_preferences` テーブル**
  - 追加カラム
    - `digest_delivery_times JSONB NOT NULL DEFAULT '["18:00"]'::jsonb`
    - `digest_timezone TEXT NULL`
    - `digest_enabled BOOLEAN NOT NULL DEFAULT true`
  - 既存レコードは `digest_enabled = true`, `digest_delivery_times = ["18:00"]`, `digest_timezone = timezone OR NULL` をセット
  - ユーザーに `user_preferences` レコードが無い場合に備え、ユースケース側でデフォルト値を補完

### アーキテクチャ設計

- `features/notification`
  - **domain/**
    - `notification.ts`: ステータス／型定義／定数
    - `recipient.ts`: 受信者とダイジェスト設定
    - `notification-target.ts`: アクティビティ＆購読者ペア表現
    - `services/notification-schedule.service.ts`: ドメインサービス／純関数
  - **domain/repositories/**
    - `notification-preparation.repository.ts`
    - `notification.repository.ts`
    - `recipient.repository.ts`（必要に応じて統合）
  - **application/use-cases/**
    - `generate-digest-notifications.use-case.ts`
  - **infra/repositories/**
    - `drizzle-notification-preparation.repository.ts`
    - `drizzle-notification.repository.ts`
  - **workers/generate-digest-notifications/**
    - `handler.ts`, `index.ts`, `__tests__/handler.test.ts`
- 依存方向: presentation/worker → application → domain → infra (DI)
  - Worker は `TransactionManager`、リポジトリ実装、ユースケースを組み立てる
  - 将来 StepFunctions の Map に拡張できるよう、ユースケースはバッチサイズ引数を受け取り、結果を返却

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/backend/src/features/notification/domain/notification.ts`**
   - ステータス定義、通知ドメイン型、メタデータ型
2. **`packages/backend/src/features/notification/domain/recipient.ts`**
   - Recipient とダイジェスト設定モデル、デフォルト値
3. **`packages/backend/src/features/notification/domain/notification-target.ts`**
   - アクティビティと購読者の結合情報
4. **`packages/backend/src/features/notification/domain/repositories/*.ts`**
   - ユースケースが利用するポート定義
5. **`packages/backend/src/features/notification/application/use-cases/generate-digest-notifications.use-case.ts`**
6. **`packages/backend/src/features/notification/domain/services/notification-schedule.service.ts`**
   - スケジュール計算ロジック（`luxon` 依存）
7. **`packages/backend/src/features/notification/infra/repositories/drizzle-notification-preparation.repository.ts`**
8. **`packages/backend/src/features/notification/infra/repositories/drizzle-notification.repository.ts`**
9. **`packages/backend/src/features/notification/workers/generate-digest-notifications/handler.ts`**
10. **`packages/backend/src/features/notification/workers/generate-digest-notifications/index.ts`**
11. **`packages/backend/src/features/notification/workers/generate-digest-notifications/__tests__/handler.test.ts`**
12. **`packages/backend/src/features/notification/domain/services/__tests__/notification-schedule.service.test.ts`**
13. **`packages/backend/infrastructure/events/notification/generate-digest-notifications.json`**

### 更新対象ファイル

1. **`packages/backend/src/db/schema.ts`**
   - `notifications`, `user_preferences` カラム追加・インデックス・ユニーク制約
2. **`packages/backend/src/db/migrations/*.sql`**
   - Drizzle Kit により生成されるマイグレーション（追加列・デフォルト値補正・ユニーク制約）
3. **`packages/backend/src/db/factories.ts`**
   - `createActivityNotification` で `scheduled_at`, `status`, `metadata` を扱えるよう拡張
   - `createUserPreference`（新設）でダイジェスト設定投入を容易にする
4. **`packages/backend/src/features/data-sources/repositories/data-source.repository.ts`**
   - ユーザーウォッチ削除時の通知削除ロジック更新（新ユニーク制約に対応）
5. **`packages/backend/scripts/lambda-config.mjs`**
   - `generate-digest-notifications` エントリ追加
6. **`packages/backend/scripts/build-lambda.mjs`**
   - 新Lambdaのビルド対象に対応（単体ビルドでも選択可能にする）
7. **`packages/backend/infrastructure/sam-template.yaml`**
   - Lambdaリソース & EventBridge ルール追加、環境変数（`DIGEST_DEFAULT_LIMIT` など）定義
8. **`packages/backend/package.json`, `pnpm-lock.yaml`**
   - 依存ライブラリ `luxon` 追加
9. **`docs/database-schema-design.md`**
   - `notifications` / `user_preferences` のカラム説明を更新
10. **`docs/project-overview.md` (任意)**

- 通知パイプライン概要の追記が必要であれば対応

## 5. テスト戦略

### Component Test（Worker）

- `generate-digest-notifications` ハンドラーの正常系: 複数アクティビティ＋購読者から期待通りの通知が作成される
- ウォッチ設定により対象外となるケース（通知無効、アクティビティ種別OFF）で作成されないこと
- 既存通知がある場合に重複生成されないこと（ユニーク制約・`onConflictDoNothing` の検証）
- `dryRun` フラグ指定時にDBが更新されないこと

### Unit Test（Application / Domain）

- `NotificationScheduleService`
  - 同日内の次スロット選択
  - 翌日に繰り上がるケース
  - タイムゾーンが異なるユーザーのスケジュール計算
  - ダイジェスト設定が空の場合にデフォルトを利用する
- `GenerateDigestNotificationsUseCase`
  - 抽出結果が0件のときに空で終了する
  - ステータスやメタデータが正しく設定される
  - リポジトリが例外を投げた場合にエラーをラップ／再送するかの挙動

### Migration Test

- `pnpm --filter backend db:generate` で生成したSQLをレビューし、既存データにも整合することを確認
- `pnpm --filter backend test` 実行時に新カラムが存在する前提で既存テストが通過することを確認

### その他

- `db/factories` の追加/変更に対するユニットテスト（任意）
- 可能であればDrizzleリポジトリに対する軽量なリポジトリテスト（`setupComponentTest` を利用）

## 6. 受け入れ基準

### 機能要件

- [ ] ウォッチ対象アクティビティに対し、購読ユーザー分の `notifications` レコードが生成される
- [ ] 非購読、通知無効、種別OFF のユーザーには通知が生成されない
- [ ] `(user_id, activity_id)` の組み合わせで重複レコードが作成されない
- [ ] ユーザー設定（またはデフォルト）に基づく `scheduled_at` が保存される
- [ ] ワーカーが EventBridge トリガで起動可能であり、ビルド／デプロイ設定が揃っている

### 非機能要件

- [ ] `pnpm format`, `pnpm lint`, `pnpm --filter backend test` が成功する
- [ ] マイグレーションが前方互換で、既存データを保持したまま適用できる
- [ ] Lambda ワーカーは複数回実行しても副作用（重複通知）が発生しない

### セキュリティ要件

- [ ] DB アクセスは既存の `TransactionManager` を介し、権限管理は既存のロールを利用する
- [ ] 個人情報（メールアドレスなど）をログに出力しない
- [ ] 環境変数に機密情報を追加する場合は `.env.example` / `sam-template.yaml` へ追記する

## 7. 実装手順

### Phase 1: データモデル整備

- 1-1. `notifications` / `user_preferences` 用マイグレーションを作成し、既存データを補正
- 1-2. `db/schema.ts`, `db/factories.ts` を更新し、新カラムに対応
- 1-3. マイグレーション実行（ローカル）とスナップショット確認
- 1-4. 作業内容を Conventional Commit（日本語メッセージ）で記録

### Phase 2: ドメイン＆ユースケース

- 2-1. 通知ドメイン、リポジトリポート、スケジュールサービスを実装
- 2-2. `GenerateDigestNotificationsUseCase` を実装し、ユニットテストを整備
- 2-3. Drizzleリポジトリ実装を追加し、必要なSQL／インデックスを確認
- 2-4. フェーズ完了時にコミットを作成

### Phase 3: ワーカー・インフラ

- 3-1. Lambda ハンドラー／index を実装し、ユースケースを組み立て
- 3-2. `scripts/lambda-config.mjs`, `sam-template.yaml`, EventBridge設定を更新
- 3-3. ワーカーのコンポーネントテストを作成し、`setupComponentTest` でDBトランザクションを管理
- 3-4. フェーズ完了時にコミットを作成

### Phase 4: 最終調整

- 4-1. ドキュメント更新（DB設計、SOW、必要に応じてプロジェクト概要）
- 4-2. `pnpm format`, `pnpm lint`, `pnpm --filter backend test` を実行し結果を記録
- 4-3. リスク・制限事項を確認し、レビュー準備（Plane のタスク更新含む）
- 4-4. 最終コミットを作成し、プッシュ前に全体を確認

## 9. リスク・考慮事項

### 技術的リスク

- **タイムゾーン計算の誤り**: JavaScript Date だけでは正確なタイムゾーン処理が難しい。`luxon` 導入と単体テストで担保する。
- **重複生成**: 並列実行時に同一 `(user_id, activity_id)` を二重作成する可能性。ユニーク制約とトランザクションで軽減。
- **既存データとの整合性**: `notifications` の過去データに `scheduled_at` を補完する際のNULL対策が必要。
- **スケジュール未設定ユーザー**: `user_preferences` レコードが存在しない場合のデフォルト処理を実装で保障する。

### 軽減策

- タイムゾーン計算は `luxon` を標準化し、UTC・Asia/Tokyo・America/Los_Angeles 等のテストケースを用意
- ドメインユースケースで `onConflictDoNothing` を利用し、生成件数をログに記録して異常検知
- マイグレーションで `scheduled_at` のバックフィルと `digest_delivery_times` のデフォルト設定を行い、適用後に `SELECT` で確認
- `user_preferences` 不存在時はユースケースでデフォルトプリセットを適用し、ログで検知可能にする
