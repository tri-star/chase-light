# SOW: CHASE-135: AI要約ダイジェスト通知への一本化

## プロジェクト概要

**課題ID**: CHASE-135  
**作成日**: 2025-10-20  
**種別**: 機能改善

## 1. 背景と目的

### 背景

- 現在の `generate-digest-notifications` ワーカーは、完成済みアクティビティごとに `notifications` レコードを個別生成しており、1回のバッチで大量の通知が作成される。
- `notifications` には活動本文の抜粋しか格納されず、日本語要約や複数活動の集約が行われていないため、ユーザー体験が低下している。
- タイムスロットベースの既存ロジックは「前回実行以降の差分抽出」ができず、再実行時に重複通知が発生するリスクを抱えている。

### 目的

- 直近のバッチ実行成功時刻から最大7日間の範囲で活動を集約し、**ユーザー単位**で1件のダイジェスト素材を生成する。
- 各活動を日本語タイトル／概要へ要約し、データソース別・アクティビティ種別別に最大3件まで整理した構造化データを作成する（最終的な本文生成は送信時に行う）。
- 集約対象アクティビティの参照リストと要約結果を正規化テーブルまたは JSON メタデータで保持し、様々な通知チャネル・フォーマットに転用できるようにする。
- バッチ実行状態（lastSuccessfulRunAt）を **ユーザーごと** に永続化し、特定ユーザーのみ再処理する運用にも対応した冪等性を確保する。

## 2. 実装スコープ

### 実装対象

- バッチ窓口 (`generate-digest-notifications` ワーカー) の処理フロー再設計とユースケース実装の刷新。
- SummarizationPort・AIアダプタを追加し、各アクティビティの日本語タイトル・概要文を生成するフォールバック付きロジックを実装。
- `notifications` メタデータ拡張、構造化されたアクティビティ情報保存用テーブル、ユーザー別実行状態テーブルなどDBスキーマを追加変更。
- Drizzleリポジトリ層の更新＋新規リポジトリ（集約抽出・構造化エントリ保存・ユーザー別実行状態管理）の実装。
- 既存テストの書き換えと新規ユニット/コンポーネントテストの追加、ドキュメント（DB設計含む）の更新。

### 更新可能な項目

1. `packages/backend/src/db/schema.ts`, `packages/backend/src/db/migrations/**`, `packages/backend/src/db/factories.ts`
2. `packages/backend/src/features/notification/domain/**`（新規ドメインオブジェクト・リポジトリポートを含む）
3. `packages/backend/src/features/notification/application/use-cases/generate-digest-notifications.use-case.ts`
4. `packages/backend/src/features/notification/application/ports/summarization.port.ts`（新規）
5. `packages/backend/src/features/notification/infra/repositories/**`, `packages/backend/src/features/notification/infra/adapters/**`
6. `packages/backend/src/features/notification/workers/generate-digest-notifications/**`
7. `packages/backend/src/test/**`, `packages/shared/src/constants/notifications.ts`
8. `docs/database-schema-design.md` ほか関連ドキュメント

### 実装除外項目

- 通知送信チャネル（メール/Slack等）の実装・設定変更
- フロントエンド/UI/API（HTTPエンドポイント）の追加・改修
- 旧 per-activity 通知実装へのロールバック用フラグやデータ移行スクリプト

## 3. 技術仕様

### ワーカー仕様

- エントリポイント: `packages/backend/src/features/notification/workers/generate-digest-notifications/handler.ts`
- 入力イベント（例）:

```jsonc
{
  "limit": 200,          // 処理対象の最大ユーザー数（省略時 DEFAULT_DIGEST_NOTIFICATION_FETCH_LIMIT）
  "dryRun": false,       // true 時はDB書き込みと lastSuccessfulRunAt 更新を行わない
  "since": "2025-10-18T00:00:00Z",  // 手動指定用（任意）
  "until": "2025-10-20T09:00:00Z"   // 手動指定用（任意）
}
```

- 出力: `created`, `skippedByConflict`, `totalExamined`, `processedUsers`, `windowSummaries`（userId と処理区間・件数の配列）
- 処理フロー:
  1. `TransactionManager.transaction` で実行し、テーブル更新と lastSuccessfulRunAt 更新を同一トランザクションに束ねる。
  2. `DigestUserStateRepository` がユーザーIDごとの `lastSuccessfulRunAt` をまとめて取得し、`now` と `limitLookbackDays` (7日) を用いて各ユーザーの対象ウィンドウ `[windowStart, windowEnd]` を決定（手動指定 `since` / `until` があれば上書き）。初回実行ユーザーは `windowStart = max(now - 7日, since)` とする。
  3. `DigestPreparationRepository` が `activities`, `data_sources`, `user_watches`, `users`, `user_preferences` を結合し、ユーザー単位・ウィンドウ内で対象アクティビティを抽出。結果はデータソース＋アクティビティ種別ごとに最大3件へ圧縮し、表示順（発生日時の降順）とリンクURLを保持する。
  4. データソース×種別ごとにまとめたエントリ配列を `SummarizationPort` へ渡し、structured output（JSON Schema）で日本語タイトル／概要を一括生成する。1グループにつき1リクエストとし、呼び出し回数を抑制する。AI例外時はグループ単位でフォールバック概要を生成し、エントリ毎の生成種別を記録する。
  5. `DigestNotificationRepository` が `notifications` レコードを挿入しつつ、構造化データを保持する `notification_digest_entries` テーブルへ `[notification_id, data_source_id, data_source_name, activity_type, activity_id, position, title, summary, url, generator]` を保存する。`metadata.digest` には集約範囲・件数・活動グループ情報、LLM呼び出し単位（groupId）とモデル・token 数などの `generatorStats` を JSON で格納し、本文 (`message`) は宛先側で組み立てやすい簡易プレースホルダー（例: `{{renderDigest}}`）とする。
  6. 正常終了時に `DigestUserStateRepository` が 対象ユーザーの `lastSuccessfulRunAt = windowEnd` を更新（`dryRun` の場合は書き込みをスキップ）。個別ユーザー再処理のため、更新はユーザー単位で行う。
  7. 実行結果をログ出力（ユーザー数、生成件数、AIフォールバック件数など）し、レスポンスで返す。
- 失敗時の取り扱い: トランザクションがロールバックされ `lastSuccessfulRunAt` は更新されない。再実行時は同じウィンドウを再処理。

### データベース操作

- **新規 `notification_digest_user_state` テーブル**  
  `user_id (UUID PK)`, `last_successful_run_at (TIMESTAMPTZ)`, `last_attempted_run_at (TIMESTAMPTZ)`, `created_at`, `updated_at`  
  - 個別ユーザーのウィンドウ管理を可能にするため、主キーは `user_id`。
  - `last_attempted_run_at` を記録し、失敗／中断時の再開ポイントを把握できるようにする。

- **新規 `notification_digest_entries` テーブル**  
  `id (UUID PK)`, `notification_id (UUID FK → notifications.id ON DELETE CASCADE)`, `data_source_id (UUID FK → data_sources.id)`, `data_source_name (TEXT)`, `activity_type (TEXT)`, `activity_id (UUID FK → activities.id)`, `position (SMALLINT)`, `title (TEXT)`, `summary (TEXT)`, `url (TEXT)`, `generator (TEXT)`, `created_at`, `updated_at`  
  - `(notification_id, data_source_id, activity_type, position)` UNIQUE 制約で順序を担保。
  - `notification_id`, `data_source_id`, `activity_id` に索引を付与し、レンダリング時の検索を最適化。

- **`notifications` テーブル更新**  
  - `activity_id` を digest 通知では `NULL` 設定（既存 UNIQUE は NULL を許容するため維持）。  
  - `metadata.digest` に `range`, `activityCount`, `groups`（データソース別・種別別の参照サマリ）, `generatorStats` などを格納する JSON Schema を整備。  
  - 本文 (`message`) はダイジェストレンダリング用プレースホルダーを設定し、送信チャネル側で柔軟に組み立てられるようにする。

- **ファクトリ・テスト補助更新**  
  - `createActivityNotification` を digest 用メタデータ/リンク挿入に対応させるヘルパー追加。  
  - `TestDataFactory` に digest 実行状態・リンクレコード生成ユーティリティを追加。

### アーキテクチャ設計

- **Domain 層**
  - `DigestWindow`（`from`, `to`, `activityCount`, `language` 等）と `DigestCandidate`（ユーザー情報 + 活動配列 + ウィンドウ情報）を新設。
  - データソース／アクティビティ種別単位で最大3件を保持する `DigestGroup`・`DigestEntry` 型を定義し、タイトル・概要・URL・generator 種別を含める。
  - `NotificationMetadata` を digest 情報を保持できるよう拡張（`digest.range`, `digest.groups`, `generatorStats` 等）。
  - 既存の `NotificationScheduleService` は本タスクでは利用せず、将来の定時配信に備えて残置するが、新ユースケースからの依存を外す。

- **Application 層**
  - `SummarizationPort`（入力: データソース×種別ごとの活動配列 / 出力: structured output で返却される日本語タイトル・概要・モデル情報・token 使用量）を追加。1グループにつき1リクエストで完結するようインターフェイスを設計。
  - `GenerateDigestNotificationsUseCase` を全面改修し、ウィンドウ決定 → 集約 → （グループ単位の）要約 → 書き込み → 状態更新のパイプラインを構築。
  - フォールバック生成ロジックを純関数として分離し、テスト容易性を確保。

- **Infra 層**
  - `DrizzleDigestPreparationRepository`, `DrizzleDigestNotificationRepository`, `DrizzleDigestUserStateRepository` を実装。
  - `SummarizationAdapter`（OpenAI API利用）と `StubSummarizationAdapter` を `infra/adapters/summarization/` に追加。structured output (JSON Schema) と function calling に対応し、グループ単位の一括要約を行う。APIキー取得は `getOpenAiConfig()` を再利用。
  - 既存 `DrizzleNotificationRepository` は digest 専用メソッドへ置き換え/統合する。

- **Workers**
  - ハンドラーでリポジトリ/アダプタを組み立て、`SummarizationPort` をDI。エラー時のログ出力と `dryRun` ハンドリングを追加。
  - レスポンスにウィンドウ情報を含め、監視で利用できるようにする。

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/backend/src/features/notification/application/ports/summarization.port.ts`**  
   - ダイジェスト要約の入出力契約を定義し、ユースケースから依存させる。
2. **`packages/backend/src/features/notification/domain/digest.ts`**  
   - DigestWindow・DigestCandidate など集約用ドメイン型とメタデータ型を定義。
3. **`packages/backend/src/features/notification/domain/repositories/digest-user-state.repository.ts`**  
   - ユーザー別 lastSuccessfulRunAt 取得/更新用ポート。
4. **`packages/backend/src/features/notification/domain/repositories/digest-notification.repository.ts`**  
   - digest 通知作成と構造化エントリ保存のポート。
5. **`packages/backend/src/features/notification/infra/repositories/drizzle-digest-preparation.repository.ts`**  
   - ウィンドウ内のユーザー別活動を抽出する Drizzle 実装。
6. **`packages/backend/src/features/notification/infra/repositories/drizzle-digest-notification.repository.ts`**  
   - `notifications` + `notification_digest_entries` を挿入する実装。
7. **`packages/backend/src/features/notification/infra/repositories/drizzle-digest-user-state.repository.ts`**  
   - ユーザー別実行状態テーブルへの読み書きを担当。
8. **`packages/backend/src/features/notification/infra/adapters/summarization/summarization.adapter.ts`**  
   - OpenAI API による要約実装。
9. **`packages/backend/src/features/notification/infra/adapters/summarization/stub-summarization.adapter.ts`**  
   - テスト／ローカル用の固定応答スタブ。
10. **`packages/backend/src/db/migrations/00xx_digest_notification_unification.sql`**  
    - 新テーブル作成とスキーマ変更を行うマイグレーション。

### 更新対象ファイル

1. **`packages/backend/src/db/schema.ts`**  
   - 新テーブル定義と `notifications` テーブルの型更新。
2. **`packages/backend/src/db/factories.ts`**  
   - digest 通知・実行状態レコードを生成できるよう拡張。
3. **`packages/backend/src/features/notification/domain/notification.ts`**  
   - メタデータ型の拡張と `NotificationDraft` の再定義。
4. **`packages/backend/src/features/notification/domain/repositories/notification-preparation.repository.ts`**  
   - 新しい集約取得メソッド・引数に差し替え。
5. **`packages/backend/src/features/notification/application/use-cases/generate-digest-notifications.use-case.ts`**  
    - 新ロジックに合わせた大幅改修（振る舞い検証はコンポーネントテストで実施）。
6. **`packages/backend/src/features/notification/infra/repositories/index.ts`**  
   - 新規Drizzle実装のエクスポート整理。
7. **`packages/backend/src/features/notification/workers/generate-digest-notifications/handler.ts`**  
   - 依存組み立て・レスポンス構造の更新。
8. **`packages/backend/src/features/notification/workers/generate-digest-notifications/__tests__/handler.test.ts`**  
   - 集約挙動・フォールバック・run state 更新確認のテストへ差し替え。
9. **`packages/backend/src/test/factories.ts`, `packages/backend/src/test/test-db.ts`**  
   - 新テーブル対応のセットアップ/クリーンアップ更新。
10. **`packages/shared/src/constants/notifications.ts`**  
    - 7日制限・最大活動件数などの定数を追加。
11. **`docs/database-schema-design.md`**  
    - 新テーブルと digest メタデータの設計を追記。

### 作成/更新/削除するファイルのツリー
```
packages/
└── backend/
    └── src/
        ├── db/
        │   ├── factories.ts (更新)
        │   ├── schema.ts (更新)
        │   └── migrations/
        │       └── 00xx_digest_notification_unification.sql (新規)
        ├── features/
        │   └── notification/
        │       ├── application/
        │       │   ├── ports/
        │       │   │   └── summarization.port.ts (新規)
        │       │   └── use-cases/
        │       │       └── generate-digest-notifications.use-case.ts (更新)
        │       ├── domain/
        │       │   ├── digest.ts (新規)
        │       │   ├── notification.ts (更新)
        │       │   └── repositories/
        │       │       ├── digest-notification.repository.ts (新規)
        │       │       ├── digest-user-state.repository.ts (新規)
        │       │       └── notification-preparation.repository.ts (更新)
        │       ├── infra/
        │       │   ├── adapters/
        │       │   │   └── summarization/
        │       │   │       ├── summarization.adapter.ts (新規)
        │       │   │       └── stub-summarization.adapter.ts (新規)
        │       │   └── repositories/
        │       │       ├── drizzle-digest-notification.repository.ts (新規)
        │       │       ├── drizzle-digest-preparation.repository.ts (新規)
        │       │       ├── drizzle-digest-user-state.repository.ts (新規)
        │       │       └── index.ts (更新)
        │       └── workers/
        │           └── generate-digest-notifications/
        │               ├── __tests__/handler.test.ts (更新)
        │               └── handler.ts (更新)
        └── test/
            ├── factories.ts (更新)
            └── test-db.ts (更新)
packages/
└── shared/
    └── src/
        └── constants/
            └── notifications.ts (更新)
docs/
└── database-schema-design.md (更新)
```

※ 削除予定ファイルはありません。

## 5. テスト戦略

### Component Test（Worker）

- `generate-digest-notifications` ハンドラーを起動し、複数ユーザー/活動が1件の通知に集約され、`notification_digest_entries` が「データソース × 種別 × 最大3件」で保存されること。
- 集約対象が無いユーザーは通知が作成されず、対象ユーザーのみの `notification_digest_user_state.last_successful_run_at` が更新されること。
- AI要約例外をスタブで投げ、フォールバック種別が `notification_digest_entries.generator` と `metadata.digest.generatorStats` に反映されること。
- 同一ユーザーを連続2回実行しても、2回目は新規活動が無ければ通知が生成されず、ウィンドウ開始時刻が前回の `lastSuccessfulRunAt` 以降になっていること。
- SummarizationPort スタブにより、1データソース×種別グループにつき1回の呼び出しでまとめて structured output を返却していることが検証できること。
- ユースケース全体の挙動は本コンポーネントテストでカバーし、UseCase 単体テストは実施しない。

### Unit Test（Domainユーティリティ）

- `DigestWindow`／ウィンドウ計算関数
  - since/until 手動指定、7日上限、ユーザー毎の異なるウィンドウなど境界値テスト。
- フォールバックメッセージ生成ヘルパー
  - 活動タイトルが欠落している場合や長文の場合でも最小限の概要を返すこと。

> ※ ユースケース全体の振る舞い検証はコンポーネントテスト（Worker）に含め、UseCase 単体テストは実施しない。

### Repository Test

- `DrizzleDigestPreparationRepository`
  - watch 設定・活動種別フィルタが尊重され、ユーザー毎のウィンドウ境界が引数で指定できること。
  - `limit` 超過時にデータソース×種別×最大3件の制約が守られること。
- `DrizzleDigestNotificationRepository`
  - 通知と `notification_digest_entries` が同一トランザクションで挿入され、`position` / UNIQUE 制約が機能すること。
  - 既存通知との衝突時に `onConflict` でスキップされ、エントリも挿入されないこと。
- `DrizzleDigestUserStateRepository`
  - 初回読み込み時に state 不存在で `null` が返り、更新時に UPSERT されること。

### その他

- マイグレーション適用テスト（`pnpm --filter backend db:migrate`）とロールバック検証。
- SummarizationAdapter の単体テスト（OpenAIレスポンス整形／サニタイズ）。必要に応じて e2e-controllable スタブを追加。

## 6. 受け入れ基準

### 機能要件

- [ ] 実行ウィンドウ内に活動が存在するユーザーには1件の digest 通知が作成され、`notification_digest_entries` にデータソース×種別ごとの最大3件のエントリが保存される。
- [ ] `metadata.digest.range.from/to` と `groups` がウィンドウ境界および集約結果を表し、`activityCount` がエントリ数と一致する。
- [ ] watch 設定が無効な活動や `activities.status != completed` のデータは通知対象外になる。
- [ ] 連続実行時にユーザー毎の `lastSuccessfulRunAt` が更新され、前回ウィンドウと重複した通知が作成されない。
- [ ] SummarizationPort がグループ単位の structured output で要約し、フォールバック時でも通知素材が作成され、エントリおよびメタデータの generator 情報に `type: "fallback"` が残る。

### 非機能要件

- [ ] `pnpm format`, `pnpm lint`, `pnpm --filter backend test` が成功する。
- [ ] マイグレーションを適用後、既存テストが全て通る。
- [ ] 7日上限・活動件数上限によりバッチ時間が許容範囲内に収まる。

### セキュリティ要件

- [ ] SummarizationAdapter は `getOpenAiConfig` 経由でAPIキーを取得し、キー値をログに出力しない。
- [ ] 要約対象データはプロンプトインジェクション対策（タグ除去等）の前処理を行う。
- [ ] 通知メタデータやログに個人情報（メールアドレス等）を含めない。

## 7. 実装手順

### Phase 1: スキーマ & 基盤整備

- 1-1. 新テーブル（user state, digest entries）と必要なインデックスを含むマイグレーションを作成。
- 1-2. `schema.ts` と `factories.ts` を更新し、テストユーティリティのセットアップ/クリーンアップを調整。
- 1-3. 既存データへの影響を確認し、`docs/database-schema-design.md` を更新。

### Phase 2: ドメイン & アプリケーション層

- 2-1. Digest ドメイン型とポート（Summarization, DigestUserState, DigestNotification）を定義。
- 2-2. `GenerateDigestNotificationsUseCase` を新パイプラインへ改修し、振る舞い検証はコンポーネントテスト（Worker）で実施。
- 2-3. フォールバックメッセージ生成ユーティリティとウィンドウ計算関数を作成。

### Phase 3: インフラ & ワーカー

- 3-1. Drizzle リポジトリ実装と SummarizationAdapter/スタブを追加。
- 3-2. ワーカーを新しいユースケース組み立てに合わせて更新し、レスポンス/ログフォーマットを調整。
- 3-3. コンポーネントテストを再構築し、実行状態テーブルやフォールバック動作をカバー。

### Phase 4: 動作検証 & ドキュメント

- 4-1. `pnpm format`, `pnpm lint`, `pnpm --filter backend test` を実行し、結果を記録。
- 4-2. 新設テーブルやメタデータ仕様をドキュメント化し、SOW の内容と差異がないか確認。
- 4-3. Plane タスクを更新し、レビュー準備（実行結果サマリ・リスク共有）を行う。

## 9. リスク・考慮事項

### 技術的リスク

- **AI要約失敗・遅延**: OpenAI API 依存によりレイテンシ/エラーが発生する可能性。
- **活動件数の増大**: 7日間に活動が集中するとバッチ処理時間やトークンコストが増大。
- **ユーザーステート不整合**: 例外発生時に特定ユーザーの `lastSuccessfulRunAt` が誤更新されると、そのユーザーだけ活動を取りこぼす可能性がある。
- **フォールバック品質**: AI失敗時のフォールバック文面が簡素すぎるとユーザー体験が損なわれる。

### 軽減策

- SummarizationPort でタイムアウト・リトライ・最大トークンを設定し、例外時はフォールバックで継続。
- `MAX_DIGEST_ENTRIES_PER_GROUP` と limit/dryRun パラメータで負荷を制御し、必要に応じログから再処理できるようにする。
- トランザクション内で通知作成とユーザーステート更新を同時に行い、例外時は全体をロールバック。
- フォールバック文面に活動タイトル＋カウント・期間を明記し、最低限の情報を保証する。
