# SOW: CHASE-135: AI要約ダイジェスト通知への一本化（前回実行以降の集約）

## プロジェクト概要

**課題ID**: CHASE-135
**作成日**: 2025-10-20
**種別**: 機能改善

## 1. 背景と目的

### 背景

現在の通知システムは、アクティビティごとに個別の通知を作成しているため、アクティビティが多い場合に通知が過剰になる問題があります。これにより、ユーザー体験が低下し、通知の見落としや疲労を引き起こす可能性があります。

リリース前段階のため、後方互換性や既存データの移行・保全は考慮する必要がありません。

### 目的

- アクティビティごとの個別通知を廃止し、AI要約を用いたダイジェスト通知へ一本化する
- 前回成功実行以降（最大過去7日まで）に発生したアクティビティをユーザー単位で集約
- 通知送信時に柔軟に組み立てられる構造化データを作成し、様々な送信フォーマットに対応
- ユーザー体験を改善し、重要な情報を効率的に伝達

## 2. 実装スコープ

### 実装対象

- **ユーザー単位の前回成功実行時刻管理**: ユーザーごとに lastSuccessfulRunAt を保持
- **ユーザー単位でのアクティビティ集約**: データソース＋アクティビティ種別ごとに最大3件まで
- **AI要約サービスの統合**: 各アクティビティの日本語化された概要を生成
- **構造化された通知データの作成**: 送信時に様々なフォーマット（Markdown、HTMLなど）に対応可能
- **冪等性の確保**: ユーザー単位の時間範囲管理による重複通知の防止

### 主要機能

1. **時間範囲管理（ユーザー単位）**
   - ユーザーごとに lastSuccessfulRunAt を管理
   - 前回成功実行時刻〜現在までの activities を対象
   - 初回実行時は最大7日過去まで遡る
   - ユーザー単位で実行完了時に lastSuccessfulRunAt を更新
   - 「特定ユーザーだけ再実行」のような運用に対応

2. **集約・抽出**
   - ユーザー設定に基づく種別フィルタ（release/issue/pr 等）
   - notificationEnabled=true のユーザーのみ対象
   - activities.status = 'completed' のみ対象
   - データソース＋アクティビティ種別ごとに最大3件まで集約

3. **AI要約（データソース＋種別単位でバッチ処理）**
   - OpenAI Structured Outputs を活用してバッチ処理
   - 1データソースの1アクティビティ種別分（最大3件）をまとめて渡す
   - JSON形式で構造化された要約を一括取得
   - API呼び出し回数を最小化してコスト削減
   - 失敗時のフォールバック（元のタイトルをそのまま使用）
   - セキュリティ・コスト対策（タイムアウト、リトライ、最大トークン制限）

4. **通知データ構造の作成**
   - 1ユーザーあたり1件の notification を作成
   - metadata に構造化された digest 情報を格納
     - データソースごとにグループ化
     - アクティビティ種別ごとにグループ化
     - 各アクティビティの情報（タイトル、概要、URL）を配列で保持
   - notification_activities テーブルで通知とアクティビティの関連を保持

### 通知データ構造のイメージ

```typescript
// notifications.metadata に格納される構造
{
  "digest": {
    "range": {
      "from": "2025-10-13T00:00:00Z",
      "to": "2025-10-20T00:00:00Z"
    },
    "language": "ja",
    "dataSources": [
      {
        "dataSourceId": "uuid-1",
        "dataSourceName": "facebook/react",
        "activityGroups": [
          {
            "type": "release",
            "activities": [
              {
                "activityId": "uuid-a",
                "title": "v18.3.0",  // バージョン番号（日本語化済み）
                "summary": "新しいフックが追加されました...",  // AI生成概要
                "url": "https://github.com/facebook/react/releases/tag/v18.3.0"
              },
              // 最大3件まで
            ]
          },
          {
            "type": "pull_request",
            "activities": [
              {
                "activityId": "uuid-b",
                "title": "パフォーマンスの改善",  // 日本語化されたPRタイトル
                "summary": "レンダリング速度が向上しました...",  // AI生成概要
                "url": "https://github.com/facebook/react/pull/12345"
              },
              // 最大3件まで
            ]
          },
          {
            "type": "issue",
            "activities": [
              // 最大3件まで
            ]
          }
        ]
      },
      // 他のデータソース...
    ]
  }
}
```

この構造により、送信時に以下のような柔軟な組み立てが可能になります：

```markdown
# Markdown 形式の例
以下のイベントが発生しました。

## facebook/react

### リリース
- [v18.3.0](URL): 新しいフックが追加されました...
- [v18.2.1](URL): バグ修正...

### Pull Request
- [パフォーマンスの改善](URL): レンダリング速度が向上しました...
```

### 実装除外項目

- 旧 per-activity 通知方式の維持・切替フラグ・キャンセルスクリプト
- SOW・パイプライン図の更新
- 送信チャネル（メール/Slack）の実装
- 実際の通知送信機能（今回は通知データの作成まで）
- 後方互換性の確保
- 既存データの移行

## 3. 技術仕様

### データベース設計

#### 3.1 新規テーブル

##### user_digest_execution_logs

ユーザー単位でワーカーの実行履歴を管理するテーブル

```sql
CREATE TABLE user_digest_execution_logs (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  worker_name VARCHAR(255) NOT NULL,
  last_successful_run_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
  UNIQUE(user_id, worker_name)
);

CREATE INDEX idx_user_digest_execution_logs_user_worker ON user_digest_execution_logs(user_id, worker_name);
CREATE INDEX idx_user_digest_execution_logs_updated_at ON user_digest_execution_logs(updated_at);
```

##### notification_activities

通知とアクティビティの多対多関係を管理する中間テーブル

```sql
CREATE TABLE notification_activities (
  notification_id UUID NOT NULL REFERENCES notifications(id) ON DELETE CASCADE,
  activity_id UUID NOT NULL REFERENCES activities(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
  PRIMARY KEY (notification_id, activity_id)
);

CREATE INDEX idx_notification_activities_notification ON notification_activities(notification_id);
CREATE INDEX idx_notification_activities_activity ON notification_activities(activity_id);
```

#### 3.2 既存テーブルの変更

##### notifications テーブル

```sql
-- activity_id を nullable に変更（複数アクティビティを集約するため）
ALTER TABLE notifications ALTER COLUMN activity_id DROP NOT NULL;

-- metadata に構造化された digest 情報を格納
-- 上記「通知データ構造のイメージ」を参照
```

### アーキテクチャ設計

既存のnotificationフィーチャーのレイヤード構成を踏襲：

#### Domain層

- **user-digest-execution-log.ts**: ユーザー単位実行履歴のエンティティ定義
- **notification.ts**: NotificationMetadata の型拡張（構造化digest情報追加）
- **digest-activity-summary.ts**: 構造化されたアクティビティ情報の型定義
- **repositories/user-digest-execution-log.repository.ts**: 実行履歴リポジトリのポート定義
- **repositories/notification-preparation.repository.ts**: 集約用メソッド追加

#### Application層

- **ports/summarization.port.ts**: AI要約サービスのポート定義（Structured Outputs使用）
  ```typescript
  interface SummarizationPort {
    summarizeActivityGroup(input: {
      dataSourceName: string
      activityType: string
      activities: Array<{
        activityId: string
        title: string
        body: string
        url: string
      }>
      language: string
      maxTokens: number
    }): Promise<{
      summaries: Array<{
        activityId: string
        title: string  // 日本語化されたタイトル
        summary: string  // 日本語要約
      }>
    }>
  }
  ```
- **use-cases/generate-digest-notifications.use-case.ts**: ユースケースの大幅改修
  - ユーザー単位の時間範囲を入力として受け取る
  - データソース＋種別ごとにグルーピング（各最大3件）
  - データソース＋種別単位でAI要約をバッチ呼び出し（Structured Outputs使用）
  - 構造化されたmetadataを作成

#### Infrastructure層

- **adapters/summarization/summarization.adapter.ts**: AI要約の実装
  - OpenAI Structured Outputs を使用
  - データソース＋種別単位でバッチ処理（最大3件）
  - タイムアウト、リトライ、トークン制限
- **adapters/summarization/summarization-stub.adapter.ts**: テスト用スタブ
- **repositories/drizzle-user-digest-execution-log.repository.ts**: 実行履歴の永続化
- **repositories/drizzle-notification-preparation.repository.ts**: 集約クエリの実装

#### Worker層

- **workers/generate-digest-notifications/handler.ts**: ハンドラーの改修
  - ユーザーごとに lastSuccessfulRunAt を取得
  - 時間範囲の計算（最大7日制限）
  - ユーザーごとに処理を実行
  - 成功したユーザーの lastSuccessfulRunAt を更新

#### Constants層

- **constants/notification.constants.ts**: マジックナンバーの定数化
  - MAX_DAYS_LOOKBACK = 7
  - MAX_ACTIVITIES_PER_DATA_SOURCE_AND_TYPE = 3
  - MAX_SUMMARY_TOKENS = 500
  - SUMMARIZATION_TIMEOUT_MS = 30000
  - DEFAULT_FALLBACK_SUMMARY = "(要約なし)"

### データフロー

```
1. ワーカー起動
   ↓
2. 通知対象ユーザー一覧を取得（notificationEnabled=true）
   ↓
3. 各ユーザーに対してループ処理
   ├→ ユーザーの lastSuccessfulRunAt 取得（初回は now - 7日）
   ├→ 時間範囲内のアクティビティを取得
   ├→ データソース＋種別ごとにグルーピング（各最大3件）
   ├→ 各グループに対してAI要約をバッチ呼び出し
   │   ├→ OpenAI Structured Outputs で一括取得
   │   └→ 失敗時はフォールバック（元のタイトルを使用）
   ├→ 構造化されたmetadataを作成
   ├→ notification レコード作成
   ├→ notification_activities レコード作成
   └→ ユーザーの lastSuccessfulRunAt 更新（成功時のみ）
   ↓
4. 全ユーザーの処理完了
```

### 冪等性の担保

- ユーザー単位の lastSuccessfulRunAt による実行ウィンドウのスライドで重複を防止
- 「特定ユーザーだけ再実行」のような運用が可能
- ユーザーごとに独立して処理されるため、一部ユーザーの失敗が他ユーザーに影響しない

### セキュリティ・コスト対策

- **AI要約サービス**
  - OpenAI Structured Outputs を使用してバッチ処理
  - データソース＋種別単位での呼び出し（最大3件/回）
  - タイムアウト設定（30秒程度）
  - リトライ回数制限（3回程度）
  - 最大トークン数制限（1000トークン程度）
  - API呼び出し回数を大幅削減（例: 30アクティビティ → 10グループ = 10回の呼び出し）
- **バッチ処理**
  - 初回実行時の過度な負荷を避けるため、最大7日遡り
  - データソース＋種別ごとに最大3件まで

## 4. 実装ファイル一覧

### 新規作成ファイル

#### Domain層

1. **packages/backend/src/features/notification/domain/user-digest-execution-log.ts**
   - UserDigestExecutionLog エンティティ定義
   - Brand型でのID管理

2. **packages/backend/src/features/notification/domain/digest-activity-summary.ts**
   - DigestActivitySummary 型定義（構造化データ）
   - DataSourceGroup, ActivityGroup 型定義

3. **packages/backend/src/features/notification/domain/repositories/user-digest-execution-log.repository.ts**
   - getLastSuccessfulRunAt(userId, workerName) メソッド
   - updateLastSuccessfulRunAt(userId, workerName, timestamp) メソッド

#### Application層

4. **packages/backend/src/features/notification/application/ports/summarization.port.ts**
   - SummarizationPort インターフェース定義
   - データソース＋種別単位でのバッチ要約生成
   - OpenAI Structured Outputs 用のスキーマ定義

#### Infrastructure層

5. **packages/backend/src/features/notification/infra/adapters/summarization/summarization.adapter.ts**
   - OpenAI Structured Outputs を使った実装
   - データソース＋種別単位でバッチ処理（最大3件）
   - JSON形式での構造化レスポンス取得
   - タイムアウト、リトライ、トークン制限

6. **packages/backend/src/features/notification/infra/adapters/summarization/summarization-stub.adapter.ts**
   - テスト用スタブ実装
   - 決定的な出力を返す

7. **packages/backend/src/features/notification/infra/repositories/drizzle-user-digest-execution-log.repository.ts**
   - Drizzle を使った永続化実装

#### Constants層

8. **packages/backend/src/features/notification/constants/notification.constants.ts**
   - MAX_DAYS_LOOKBACK = 7
   - MAX_ACTIVITIES_PER_DATA_SOURCE_AND_TYPE = 3
   - MAX_SUMMARY_TOKENS = 1000（バッチ処理用に増量）
   - SUMMARIZATION_TIMEOUT_MS = 30000
   - DEFAULT_FALLBACK_SUMMARY = "(要約なし)"

### 更新対象ファイル

#### Database Schema

1. **packages/backend/src/db/schema.ts**
   - `userDigestExecutionLogs` テーブル定義追加
   - `notificationActivities` テーブル定義追加
   - `notifications.activityId` を nullable に変更
   - リレーション定義の追加

#### Domain層

2. **packages/backend/src/features/notification/domain/notification.ts**
   - `NotificationMetadata` の型拡張（構造化digest情報追加）
   - `NotificationDraft` の `activityId` を optional に変更

3. **packages/backend/src/features/notification/domain/repositories/notification-preparation.repository.ts**
   - `findActivitiesForDigest` メソッド追加
   - 入力パラメータ: userId, timeRange, dataSourceAndTypeLimit

#### Infrastructure層

4. **packages/backend/src/features/notification/infra/repositories/drizzle-notification-preparation.repository.ts**
   - `findActivitiesForDigest` の実装
   - ユーザー単位での時間範囲フィルタ
   - データソース＋種別ごとに最大3件まで取得

5. **packages/backend/src/features/notification/infra/repositories/drizzle-notification.repository.ts**
   - `createMany` メソッドの改修（notification_activities の作成を含む）
   - または `createDigestNotification` メソッドの新規追加

#### Application層

6. **packages/backend/src/features/notification/application/use-cases/generate-digest-notifications.use-case.ts**
   - 大幅改修
   - ユーザー単位の時間範囲を入力として受け取る
   - データソース＋種別ごとにグルーピング（各最大3件）
   - グループ単位でAI要約をバッチ呼び出し（Structured Outputs使用）
   - 構造化されたmetadataを作成
   - フォールバック処理

#### Worker層

7. **packages/backend/src/features/notification/workers/generate-digest-notifications/handler.ts**
   - 通知対象ユーザー一覧の取得
   - ユーザーごとの lastSuccessfulRunAt 取得
   - 時間範囲の計算（最大7日制限）
   - ユーザーごとにユースケースを実行
   - ユーザーごとに lastSuccessfulRunAt を更新（成功時のみ）
   - エラーハンドリング

### マイグレーションファイル（自動生成）

8. **packages/backend/src/db/migrations/XXXX_add_digest_notification_tables.sql**
   - Drizzle Kit により自動生成
   - `pnpm --filter backend db:generate` で生成

## 5. テスト戦略

### Component Test（Worker層のみ）

Worker層のエントリポイントで、実際のDB・スタブアダプタを使った統合テストを実施します。

- **正常系**
  - アクティビティが存在する場合、ユーザー単位で1件の通知が作成される
  - 複数ユーザーに対して、それぞれ1件ずつ通知が作成される
  - ユーザーごとの lastSuccessfulRunAt が正しく更新される
  - metadata に構造化されたdigest情報が正しく格納される
  - notification_activities に関連が正しく保存される
  - データソース＋種別ごとに最大3件までのアクティビティが含まれる

- **境界値テスト**
  - 初回実行時（lastSuccessfulRunAt が存在しない）
  - 7日より古いアクティビティは含まれない
  - 前回実行以降にアクティビティが存在しない場合
  - データソース＋種別ごとに4件以上のアクティビティがある場合（最新3件のみ）

- **冪等性テスト**
  - ワーカーを連続2回実行しても重複通知が作成されない
  - 特定ユーザーだけ再実行した場合、そのユーザーのみ通知が再作成される

- **エラーハンドリング**
  - AI要約が失敗した場合、フォールバック処理が動作する
  - 一部ユーザーの処理が失敗しても、他ユーザーの処理は継続される
  - 失敗したユーザーの lastSuccessfulRunAt は更新されない

- **ユーザー設定フィルタ**
  - notificationEnabled=false のユーザーは処理対象外
  - watchReleases, watchIssues, watchPullRequests が正しく適用される
  - status != 'completed' のアクティビティは除外される

### Unit Test / Repository Test / Adapter Test

ガイドラインに従い、以下の層ではテストを実装しません：

- UseCase層
- Repository層
- Adapter層

すべてのテストケースは、Worker層のComponent Testで統合的に検証します。

## 6. 受け入れ基準

### 機能要件

- [ ] ユーザーごとに、実行ウィンドウ内のアクティビティが1件以上存在する場合、通知が1件だけ作成される
- [ ] 通知の metadata に構造化された digest 情報が正しく格納される
  - [ ] dataSources 配列にデータソースがグループ化されている
  - [ ] 各データソースの activityGroups に種別ごとにグループ化されている
  - [ ] 各アクティビティに title, summary, url が含まれている
- [ ] notification_activities テーブルに、通知とアクティビティの関連が正しく保存される
- [ ] データソース＋種別ごとに最大3件までのアクティビティが含まれる
- [ ] ユーザー設定（通知有効・種別フィルタ）が正しく反映される
- [ ] ユーザーごとに前回成功実行以降（最大7日）のアクティビティが対象となる
- [ ] AI要約が正常に動作し、各アクティビティの日本語概要が生成される
- [ ] AI要約が失敗した場合、フォールバック処理が動作し通知作成が継続される

### 非機能要件

- [ ] 再実行時に重複通知が作成されない（ユーザー単位の lastSuccessfulRunAt により抑止）
- [ ] 特定ユーザーだけ再実行できる
- [ ] 一部ユーザーの処理が失敗しても、他ユーザーの処理は継続される
- [ ] pnpm format が成功する
- [ ] pnpm lint が成功する
- [ ] pnpm --filter backend test が成功する
- [ ] 既存のテストが全て通る
- [ ] AI要約サービスのタイムアウト・リトライが正しく動作する
- [ ] 初回実行時の負荷が許容範囲内である（最大7日＋最大3件/グループ）

### セキュリティ要件

- [ ] AI要約サービスへの入力が適切にサニタイズされている
- [ ] タイムアウト・リトライ・トークン制限が適切に設定されている
- [ ] エラーメッセージに機密情報が含まれていない

## 7. 実装手順

### Phase 1: データベース設計とマイグレーション

- 1-1. `schema.ts` に `userDigestExecutionLogs` テーブル定義を追加
- 1-2. `schema.ts` に `notificationActivities` テーブル定義を追加
- 1-3. `notifications.activityId` を nullable に変更
- 1-4. リレーション定義を追加
- 1-5. `pnpm --filter backend db:generate` でマイグレーションファイルを生成
- 1-6. マイグレーションファイルの内容を確認
- 1-7. `pnpm --filter backend db:migrate` でマイグレーションを実行

### Phase 2: Domain層の実装

- 2-1. `user-digest-execution-log.ts` の作成
- 2-2. `digest-activity-summary.ts` の作成（構造化データ型定義）
- 2-3. `repositories/user-digest-execution-log.repository.ts` の作成
- 2-4. `notification.ts` の `NotificationMetadata` 拡張
- 2-5. `notification.ts` の `NotificationDraft` 型変更
- 2-6. `repositories/notification-preparation.repository.ts` にメソッド追加
- 2-7. 定数ファイル `constants/notification.constants.ts` の作成

### Phase 3: Infrastructure層の実装（Repository）

- 3-1. `drizzle-user-digest-execution-log.repository.ts` の実装
- 3-2. `drizzle-notification-preparation.repository.ts` に `findActivitiesForDigest` 実装
- 3-3. `drizzle-notification.repository.ts` の改修（notification_activities 対応）

### Phase 4: Application層の実装（Port）

- 4-1. `ports/summarization.port.ts` の作成
- 4-2. `infra/adapters/summarization/summarization-stub.adapter.ts` の実装

### Phase 5: Application層の実装（UseCase）

- 5-1. `generate-digest-notifications.use-case.ts` の大幅改修
  - ユーザー単位の時間範囲を入力として受け取る
  - データソース＋種別ごとにグルーピング（各最大3件）
  - グループ単位でAI要約をバッチ呼び出し（Structured Outputs使用）
  - 構造化されたmetadataを作成
  - フォールバック処理

### Phase 6: Infrastructure層の実装（Adapter）

- 6-1. `infra/adapters/summarization/summarization.adapter.ts` の実装
  - OpenAI Structured Outputs の統合
  - データソース＋種別単位でのバッチ処理
  - JSON形式での構造化レスポンス取得
  - タイムアウト、リトライ、トークン制限

### Phase 7: Worker層の実装とテスト

- 7-1. `workers/generate-digest-notifications/handler.ts` の改修
  - 通知対象ユーザー一覧の取得
  - ユーザーごとの lastSuccessfulRunAt 取得
  - 時間範囲の計算（最大7日制限）
  - ユーザーごとにユースケースを実行
  - ユーザーごとに lastSuccessfulRunAt を更新（成功時のみ）
  - エラーハンドリング
- 7-2. `handler.ts` のコンポーネントテスト作成・実行
  - 正常系テスト
  - 境界値テスト
  - 冪等性テスト
  - エラーハンドリングテスト
  - ユーザー設定フィルタテスト

### Phase 8: 統合テストと最終検証

- 8-1. 全テストの実行（`pnpm --filter backend test`）
- 8-2. lint・format の実行
- 8-3. 受け入れ基準の確認
- 8-4. ドキュメントの更新（必要に応じて）

## 8. リスク・考慮事項

### 技術的リスク

#### AI要約サービスの不安定性
- **リスク**: AI APIが一時的に利用不可能になる、レスポンスが遅い
- **影響度**: 中
- **軽減策**:
  - タイムアウト・リトライの適切な設定
  - フォールバック処理の実装（元のタイトルを使用）
  - スタブアダプタでのテスト

#### ユーザー単位の lastSuccessfulRunAt 管理
- **リスク**: 一部ユーザーの処理が失敗した場合、そのユーザーのみ次回リトライが必要
- **影響度**: 低
- **軽減策**:
  - ユーザーごとに独立して処理
  - 失敗したユーザーの lastSuccessfulRunAt は更新しない
  - エラーログを確実に出力

#### データ量の増加
- **リスク**: 初回実行時に7日分のデータを処理する負荷が高い
- **影響度**: 中
- **軽減策**:
  - 最大7日遡り＋データソース＋種別ごとに最大3件
  - ユーザーごとに分散処理
  - パフォーマンステスト

#### 通知の重複
- **リスク**: 再実行時に同じ通知が複数作成される
- **影響度**: 高
- **軽減策**:
  - ユーザー単位の lastSuccessfulRunAt による時間範囲管理
  - 冪等性テストの実施

### 運用リスク

#### AI要約のコスト
- **リスク**: API呼び出し回数が増えてコストが増大
- **影響度**: 低
- **軽減策**:
  - OpenAI Structured Outputs によるバッチ処理
  - データソース＋種別単位での呼び出し（最大3件/回）
  - API呼び出し回数を大幅削減（例: 30アクティビティ → 10グループ）
  - トークン数制限（1000トークン）
  - モニタリング

#### 特定ユーザーの再実行
- **リスク**: 再実行時の運用が複雑になる可能性
- **影響度**: 低
- **軽減策**:
  - ユーザー単位の lastSuccessfulRunAt により対応可能
  - ログ出力の充実

### スケジュール

- **全体**: 8フェーズ、各フェーズ0.5〜2日程度
- **見積もり**: 合計7〜12日程度

## 9. 参考資料

- CHASE-135 課題詳細
- `packages/backend/docs/guidelines/folder-structure.md`
- `packages/backend/docs/guidelines/testing-strategy.md`
- `packages/backend/docs/guidelines/api-implementation-guide.md`
- `packages/backend/src/features/detection` （参照実装）
