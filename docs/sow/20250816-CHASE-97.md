# SOW: CHASE-97: Auth0トークンの再発行処理

## プロジェクト概要

**課題ID**: CHASE-97
**作成日**: 2025-08-16
**種別**: 機能改善

## 1. 背景と目的

### 背景

現在のシステムでは、Auth0のアクセストークンが期限切れになった際の自動再発行機能が実装されていません。Auth0のアクセストークンの有効期限は通常1時間程度であり、ユーザーが長時間セッションを継続した場合、APIリクエストが認証エラーで失敗する問題があります。

### 目的

- Auth0のアクセストークンの自動更新機能を実装し、ユーザーの操作を中断させることなく継続的なサービス利用を可能にする
- セッション管理機能を一元化し、認証関連のコードの保守性を向上させる
- リフレッシュトークンを活用した安全なトークン更新機能を提供する

## 2. 実装スコープ

### 実装対象

- Auth0コールバック処理におけるトークン有効期限の保存
- サーバーサイドミドルウェアによる認証チェック + トークン自動更新機能
- セッション管理機能の統合と新しいアクセストークン取得関数の実装
- 既存の個別認証判定ロジックの削除とコードのリファクタリング

### 更新可能な項目

1. Auth0のアクセストークンとリフレッシュトークンの管理
2. セッション情報におけるトークン有効期限の保存
3. ミドルウェアによる集約された認証処理
4. アクセストークン取得のためのユーティリティ関数

### 実装除外項目

- Auth0の設定変更（既存のAuth0設定をそのまま利用）
- フロントエンド側の認証処理の変更（サーバーサイドのみの改修）
- セッション暗号化方式の変更（既存の暗号化方式を継続利用）

## 3. 技術仕様

### 認証・認可

- 既存のJWT認証方式を継続
- リフレッシュトークンによるアクセストークンの自動更新
- トークン更新失敗時の適切なエラーハンドリング（401エラー）

### トークン更新処理

#### 更新タイミング
- アクセストークンの有効期限が1分未満になった場合に自動更新

#### 更新フロー
1. ミドルウェアでセッション情報を取得
2. アクセストークンの有効期限をチェック
3. 期限が1分未満の場合、リフレッシュトークンでアクセストークンを再発行
4. 新しいトークンをセッションに保存
5. リフレッシュ失敗時は401エラーを返す

### セッション管理

#### セッション情報の拡張
```typescript
export interface UserSession {
  id: string
  userId?: string
  email?: string
  name?: string
  avatar?: string
  provider?: string
  accessToken?: string
  refreshToken?: string
  accessTokenExpiresAt?: Date  // 新規追加
  expiresAt?: Date
  createdAt: Date
  updatedAt: Date
  loggedInAt: Date
  [key: string]: unknown
}
```

### アーキテクチャ設計

既存のNuxt.jsサーバーサイドアーキテクチャを活用：

- **Middleware層**: 新規作成する認証ミドルウェア
- **Utils層**: セッション管理機能の拡張
- **API層**: 既存の個別認証処理の削除

## 4. 実装ファイル一覧

### 新規作成ファイル

1. **`packages/frontend/server/api/middleware/auth.ts`**
   - 認証チェック + トークン自動更新機能
   - ログインエンドポイントは処理対象外とする

### 更新対象ファイル

1. **`packages/frontend/server/api/auth/callback.get.ts`**
   - トークン有効期限をセッション情報に追加

2. **`packages/frontend/server/utils/session.ts`**
   - `UserSession`インターフェースに`accessTokenExpiresAt`追加
   - `getAccessTokenFromSession()`関数の実装
   - `setUserSession()`でトークン有効期限の保存

3. **`packages/frontend/server/api/data-sources/index.get.ts`**
   - `requireUserSession(event)`の削除

4. **`packages/frontend/server/api/data-sources/index.post.ts`**
   - `requireUserSession(event)`の削除

5. **`packages/frontend/server/api/protected/test.get.ts`**
   - `requireUserSession(event)`の削除

6. **`packages/frontend/libs/orval/custom-fetch.ts`**
   - `getAccessTokenFromALS`から`getAccessTokenFromSession`への変更

### 削除対象ファイル

1. **`packages/frontend/server/utils/session-als.ts`**
   - 機能を`session.ts`に統合後削除

## 5. テスト戦略

### Unit Test（Utils層）

- `getAccessTokenFromSession()`の正常系・異常系
- トークン有効期限チェックロジック
- `refreshAccessToken()`の正常系・異常系（Auth0をモック）
- セッション更新処理のテスト

### Unit Test（Middleware層）

- 認証ミドルウェアの動作確認
- トークン期限切れ検知の動作
- リフレッシュトークン呼び出し処理（Auth0をモック）
- セッション更新処理
- リフレッシュトークンが無効な場合の401エラー処理
- ログインエンドポイントの除外処理
- 各種エラーケースの処理

### Component Test（Presentation層）

- 認証済みユーザーによる正常なAPI呼び出し
- ミドルウェアを通過した正常なAPIリクエスト
- ミドルウェアでブロックされた401レスポンス
- ログインエンドポイントがミドルウェア処理をスキップすること

**注意：** Presentation層では外部サービス（Auth0）を直接テストせず、ミドルウェアの動作をモックしてテストします。Auth0関連の詳細なテストはMiddleware層とUtils層で実施します。

## 6. 受け入れ基準

### 機能要件

- [ ] アクセストークンの有効期限が1分未満の場合に自動更新される
- [ ] リフレッシュトークンによる正常なトークン更新が動作する
- [ ] トークン更新失敗時に適切に401エラーが返される
- [ ] ログインエンドポイントがミドルウェア処理の対象外になる
- [ ] 既存のAPI機能が正常に動作する

### 非機能要件

- [ ] 既存のテストが全て通る
- [ ] 同時並列リクエスト時の競合状態に対応できる
- [ ] セッション管理が一元化される

### セキュリティ要件

- [ ] リフレッシュトークンが安全に管理される
- [ ] 無効なトークンによる不正アクセスが適切に拒否される
- [ ] トークン更新処理中の情報漏洩防止

## 7. 実装手順

### Phase 1: セッション管理機能の拡張

- 1-1. `UserSession`インターフェースに`accessTokenExpiresAt`追加
- 1-2. `getAccessTokenFromSession()`関数の実装
- 1-3. `setUserSession()`の更新（トークン有効期限保存）
- 1-4. ユニットテストの作成・実行

### Phase 2: Auth0コールバック処理の更新

- 2-1. `callback.get.ts`でトークン有効期限の計算・保存
- 2-2. 統合テストの実行

### Phase 3: 認証ミドルウェアの実装

- 3-1. `auth.ts`ミドルウェアの作成
- 3-2. トークン期限チェック + 自動更新ロジック
- 3-3. ログインエンドポイント除外処理
- 3-4. ミドルウェアのテスト作成・実行

### Phase 4: 既存コードのリファクタリング

- 4-1. 各APIルートから`requireUserSession(event)`削除
- 4-2. `custom-fetch.ts`の関数呼び出し変更
- 4-3. `session-als.ts`の削除
- 4-4. 全体的な回帰テスト実行

## 8. リスク・考慮事項

### 技術的リスク

- **並行リクエスト競合**: 同時に複数のアクセストークン発行が実行される可能性
- **Auth0レート制限**: リフレッシュトークンの頻繁な利用による制限
- **セッション整合性**: トークン更新中のセッション状態管理

### 軽減策

- Auth0のリフレッシュトークンLeeway（10秒程度）を活用し、同時発行の影響を軽減
- トークン更新タイミングを1分前に設定し、レート制限を回避
- 段階的実装とテストによる品質確保
- 既存テストによる回帰テスト実施

### 懸念事項への対応

課題で言及されている同時並列リクエストの問題について：
- Auth0のリフレッシュトークンは10秒程度のLeewayを持つため、同時発行されても最終的に有効なトークンが残る設計
- 最後に発行されたアクセストークンが有効になる仕様を活用