# 認証

## ステータス

決定済み

## コンテキスト

- 今回のプロジェクトではAuth0を利用して認証関連処理を実装するとどうなるか確認する目的がある
- SPAとSSRの両方があるアプリケーションに組み込むにあたり、どのように組み込むかを決定する必要がある
  - Nuxt.jsのnuxt-auth-utilsなど使うライブラリによってセッション管理方法も変わるため、
    どのライブラリを使うかも決定に影響する

## 用語

- API: アプリケーションのバックエンドサービス。
  ユーザー情報やアプリケーション内で管理しているリポジトなどのデータにアクセスするためのインターフェース。
- SPA： ブラウザ上で動作するNuxt.jsアプリケーション
- サーバーサイド(SSR): Nuxt.jsのSSRで動作するアプリケーション。

## 決定

### 決定内容

- トークンの発行方法
  - **SSR主導の認証**
  - Auth0アプリケーションは1つ（Regular Web Application）で、認可コードフローはSSR側でのみ実行
  - SPAは認証状態をSSRから取得し、APIアクセスもSSR経由で行う
- トークンの管理方法
  - **セッションに保存**
  - サーバーサイドでトークンを発行・管理し、アクセストークン・リフレッシュトークンの両方をPostgreSQLのDBに保存されたセッションで管理
  - セッションIDのみをCookieに保存
- 認証ライブラリ
  - **自前実装（一部nuxt-auth-utilsの参考）**
  - セッション管理機能を独自実装し、Auth0との連携部分でSDKを活用

### 決定理由

業務で実装する一般的な中規模Webアプリケーションのベストプラクティスを優先し、セキュリティと保守性を重視した結果：

**トークンの発行方法について：**
- SSR主導の認証は業務アプリケーションで最も一般的なパターン
- Auth0アプリケーション1つで済み、認可フローも1回のみで冗長性を回避
- SPAとSSRで一貫した認証状態管理が可能
- 実装・運用コストを抑制できる

**トークンの管理方法について：**
- セキュリティ面で最も堅牢（トークンがクライアント側に露出しない）
- 業務アプリケーションの標準的なアプローチ
- トークン漏洩リスクを最小化できる
- セッションIDのみがCookieに保存されるため、攻撃対象を限定できる

**認証ライブラリについて：**
- 業務要件に応じたカスタマイズが容易
- セッション管理の実装を学習できる
- 保守性の観点で自社でコントロール可能

## 考慮した選択肢

今回はAuth0を利用することまでは決定していますが、どのように組み込むかは色々と検討の余地があります。

### トークンの発行方法

#### SPAだけで認証を行う

この場合、SPA側でトークン発行の手続きを済ませてAPIを利用します。
サーバーサイド側ではAPI発行を行わない範囲をレンダリングすることになります。

#### SPA/SSR両方で認証を行う

SPAではPKCEを利用してトークン発行を行い、
サーバーサイド側ではAuth0のサーバーサイドSDK、またはnuxt-auth-utilsなどを利用してトークン発行を行います。

これであればSSR側でもAPIを利用することが出来ます。

#### SSRだけで認証を行う

SPAではサーバーサイドのAPIルートを利用してAPIを呼び出し、
トークンはサーバーサイドで発行、保存することで、SPA側がトークンを意識することなくAPIを利用できるようにします。

この場合、SPAからのAPIリクエストは全てサーバーサイドを経由することになりますが、
次のようなメリットがあります。

- SPA側でトークンを管理する必要がなくなる
- SPA/サーバーサイドどちらも同じ方法でAPIルートを利用するコードで実装が可能
- サーバーサイドはAPIルートの呼び出しは通常の関数呼び出しの動作になるため、この部分のオーバーヘッドが少ない
- APIルートで定義するAPIが、実質BFFのような使い方が出来る

一方で、次のようなデメリットもあります。

- SPA側のAPIリクエストが全てサーバーサイドを経由する必要がある
  - SPA側から見るとレイテンシーが増加することになる
  - サーバーサイドに負荷が掛かる
    - Lambdaを利用するのでスケール面の負荷の心配は少ない
- バックエンドAPIに加えてAPIルート上にも同じようなAPIを実装する必要があり冗長

### トークンの管理方法

#### ローカルストレージに保存(1)

SPA側で利用するためにローカルストレージに保存します。
リフレッシュトークンもローカルストレージに保存することになりそうですが、
リフレッシュトークンは寿命がとても長く、これもローカルストレージに保存することには懸念があります。

#### ローカルストレージに保存(2)

アクセストークンだけをローカルストレージに保存します。
リフレッシュトークンはサーバーサイドで管理し、トークン再発行用のAPIをAPIルートで実装します。

#### Cookieに保存(1)

セキュリティの観点からHttpOnlyCookieに保存が必要になります。
この場合はSPA側ではこのトークンを利用することが出来ないので、後述する暗号化したCookieを利用しサーバーサイドで利用することになります。

#### 暗号化したCookieに保存

サーバーサイドでトークンを発行、管理し、アクセストークン、リフレッシュトークンの両方を暗号化したCookieに保存します。

暗号化したCookieに保存する場合は、オフラインで解析が可能な点が懸念されます。
リフレッシュトークンの有効期限は現在60日としていますが、この間に解析が不可能であれば一旦は懸念は解消されます。
(そもそもCookieの内容を取得されればそれがそのままセッションの乗っ取りを意味するため、
この点は心配しても仕方がないでしょうか。
セッションIDをCookieに保存する方法もこの点は同じかもしれません)

nuxt-auth-utilsを利用するとセッション情報を暗号化したCookieに格納するため、
この方式を採用する場合実装面のコストが低くなります。

#### セッションに保存

サーバーサイドでトークンを発行、管理し、アクセストークン、リフレッシュトークンの両方をセッションに保存します。
セッションIDをCookieに保存することで、アクセストークン、リフレッシュトークンがCookie上に保存されることを避けることが出来ます。

Nuxt.jsではセッション情報をRedisやDBに記録する機能は直接は存在しないため、独自の実装が必要になります。

また、コストの観点からRedisは採用できないので、保存先はPostgreSQLのDBになります。
トランザクション中にセッション情報を更新するとデッドロックの懸念があるため、
セッション情報の更新はトランザクション外で行う等注意が必要です。

## 結果・影響

<!--
TODO:
- この決定がシステムや開発に与える影響
- 今後の対応や残課題
-->

## 参考資料

<!--
TODO:
- 関連ドキュメントや外部リンク
-->
