# 認証

## ステータス

決定済み

## コンテキスト

- 今回のプロジェクトではAuth0を利用して認証関連処理を実装するとどうなるか確認する目的がある
- SPAとSSRの両方があるアプリケーションに組み込むにあたり、どのように組み込むかを決定する必要がある
  - Nuxt.jsのnuxt-auth-utilsなど使うライブラリによってセッション管理方法も変わるため、
    どのライブラリを使うかも決定に影響する

## 用語

- API: アプリケーションのバックエンドサービス。
  ユーザー情報やアプリケーション内で管理しているリポジトなどのデータにアクセスするためのインターフェース。
- SPA： ブラウザ上で動作するNuxt.jsアプリケーション
- サーバーサイド(SSR): Nuxt.jsのSSRで動作するアプリケーション。

## 決定

### 決定内容

- トークンの発行方法
  - **SSR主導の認証**
  - Auth0アプリケーションは1つ（Regular Web Application）で、認可コードフローはSSR側でのみ実行
  - SPAは認証状態をSSRから取得し、APIアクセスもSSR経由で行う
- トークンの管理方法
  - **セッションに保存**
  - サーバーサイドでトークンを発行・管理し、アクセストークン・リフレッシュトークンの両方をPostgreSQLのDBに保存されたセッションで管理
  - セッションIDのみをCookieに保存
- 認証ライブラリ
  - **自前実装（一部nuxt-auth-utilsの参考）**
  - セッション管理機能を独自実装し、Auth0との連携部分でSDKを活用

### 決定理由

業務で実装する一般的な中規模Webアプリケーションのベストプラクティスを優先し、セキュリティと保守性を重視した結果：

**トークンの発行方法について：**

- SSR主導の認証は業務アプリケーションで最も一般的なパターン
- Auth0アプリケーション1つで済み、認可フローも1回のみで冗長性を回避
- SPAとSSRで一貫した認証状態管理が可能
- 実装・運用コストを抑制できる

**トークンの管理方法について：**

- セキュリティ面で最も堅牢（トークンがクライアント側に露出しない）
- 業務アプリケーションの標準的なアプローチ
- トークン漏洩リスクを最小化できる
- セッションIDのみがCookieに保存されるため、攻撃対象を限定できる

**認証ライブラリについて：**

- 業務要件に応じたカスタマイズが容易
- セッション管理の実装を学習できる
- 保守性の観点で自社でコントロール可能

## 考慮した選択肢

今回はAuth0を利用することまでは決定していますが、どのように組み込むかは色々と検討の余地があります。

### トークンの発行方法

#### SPAだけで認証を行う

この場合、SPA側でトークン発行の手続きを済ませてAPIを利用します。
サーバーサイド側ではAPI発行を行わない範囲をレンダリングすることになります。

#### SPA/SSR両方で認証を行う

SPAではPKCEを利用してトークン発行を行い、
サーバーサイド側ではAuth0のサーバーサイドSDK、またはnuxt-auth-utilsなどを利用してトークン発行を行います。

これであればSSR側でもAPIを利用することが出来ます。

#### SSRだけで認証を行う

SPAではサーバーサイドのAPIルートを利用してAPIを呼び出し、
トークンはサーバーサイドで発行、保存することで、SPA側がトークンを意識することなくAPIを利用できるようにします。

この場合、SPAからのAPIリクエストは全てサーバーサイドを経由することになりますが、
次のようなメリットがあります。

- SPA側でトークンを管理する必要がなくなる
- SPA/サーバーサイドどちらも同じ方法でAPIルートを利用するコードで実装が可能
- サーバーサイドはAPIルートの呼び出しは通常の関数呼び出しの動作になるため、この部分のオーバーヘッドが少ない
- APIルートで定義するAPIが、実質BFFのような使い方が出来る

一方で、次のようなデメリットもあります。

- SPA側のAPIリクエストが全てサーバーサイドを経由する必要がある
  - SPA側から見るとレイテンシーが増加することになる
  - サーバーサイドに負荷が掛かる
    - Lambdaを利用するのでスケール面の負荷の心配は少ない
- バックエンドAPIに加えてAPIルート上にも同じようなAPIを実装する必要があり冗長

### トークンの管理方法

#### ローカルストレージに保存(1)

SPA側で利用するためにローカルストレージに保存します。
リフレッシュトークンもローカルストレージに保存することになりそうですが、
リフレッシュトークンは寿命がとても長く、これもローカルストレージに保存することには懸念があります。

#### ローカルストレージに保存(2)

アクセストークンだけをローカルストレージに保存します。
リフレッシュトークンはサーバーサイドで管理し、トークン再発行用のAPIをAPIルートで実装します。

#### Cookieに保存(1)

セキュリティの観点からHttpOnlyCookieに保存が必要になります。
この場合はSPA側ではこのトークンを利用することが出来ないので、後述する暗号化したCookieを利用しサーバーサイドで利用することになります。

#### 暗号化したCookieに保存

サーバーサイドでトークンを発行、管理し、アクセストークン、リフレッシュトークンの両方を暗号化したCookieに保存します。

暗号化したCookieに保存する場合は、オフラインで解析が可能な点が懸念されます。
リフレッシュトークンの有効期限は現在60日としていますが、この間に解析が不可能であれば一旦は懸念は解消されます。
(そもそもCookieの内容を取得されればそれがそのままセッションの乗っ取りを意味するため、
この点は心配しても仕方がないでしょうか。
セッションIDをCookieに保存する方法もこの点は同じかもしれません)

nuxt-auth-utilsを利用するとセッション情報を暗号化したCookieに格納するため、
この方式を採用する場合実装面のコストが低くなります。

#### セッションに保存

サーバーサイドでトークンを発行、管理し、アクセストークン、リフレッシュトークンの両方をセッションに保存します。
セッションIDをCookieに保存することで、アクセストークン、リフレッシュトークンがCookie上に保存されることを避けることが出来ます。

Nuxt.jsではセッション情報をRedisやDBに記録する機能は直接は存在しないため、独自の実装が必要になります。

また、コストの観点からRedisは採用できないので、保存先はPostgreSQLのDBになります。
トランザクション中にセッション情報を更新するとデッドロックの懸念があるため、
セッション情報の更新はトランザクション外で行う等注意が必要です。

<a href="#testing-strategy" id="testing-strategy"></a>

## テスト戦略

### E2Eテストにおける認証処理

**決定：** Auth0 Machine-to-Machine (M2M) 認証とテスト専用エンドポイントのハイブリッドアプローチ

#### 選択理由

Auth0公式ドキュメントではM2M認証がPlaywright E2Eテストの推奨アプローチとして示されているが、開発初期段階では以下の段階的実装を採用：

1. **Phase 1: テスト専用エンドポイント** （即座に実装可能）

   - 開発・テスト環境でのみ有効な認証バイパス
   - 基本的なE2Eテストの迅速な実装
   - 実装コストが最小

2. **Phase 2: Auth0 M2M認証** （本格運用向け）

   - Auth0でM2Mアプリケーションを作成
   - より本番環境に近い認証フロー
   - セキュリティベストプラクティスに準拠

3. **Phase 3: 完全な認証フローテスト** （将来的）
   - 実際のAuth0ログインフローをテスト
   - エラーケースとセッション管理のテスト

#### メリット

**テスト専用エンドポイント:**

- 開発速度の向上（認証設定なしでテスト実行可能）
- Auth0設定の複雑さを回避
- CIでの安定性（外部依存の削減）
- テストデータの一貫性

**M2M認証:**

- Auth0公式推奨のベストプラクティス
- 本番環境により近いテスト条件
- セキュリティ面での堅牢性
- 実際の認証フローの検証

#### 実装方針

```typescript
// server/api/auth/test-login.post.ts
// 開発・テスト環境でのみ有効な認証バイパス
export default defineEventHandler(async (event) => {
  if (process.env.APP_STAGE === "production") {
    throw createError({
      statusCode: 404,
      statusMessage: "Not Found",
    });
  }
  // テスト用セッション作成ロジック
});
```

この段階的アプローチにより、開発効率を維持しながら長期的なテスト品質を確保する。

## 結果・影響

### 実装への影響

**ポジティブな影響:**

- セキュリティリスクの最小化（トークンのクライアント露出回避）
- 一貫した認証状態管理（SSR/SPA間）
- 保守性の向上（自社制御可能な実装）
- 開発効率の向上（テスト専用エンドポイントによる）

**考慮事項:**

- 初期実装コストの増加（自前実装のため）
- サーバーサイド経由のAPIアクセスによるレイテンシー
- セッション管理の実装・運用複雑性

### 今後の対応

1. **短期（実装フェーズ）:**

   - テスト専用エンドポイントの実装
   - 基本的なE2Eテストスイートの構築
   - セッション管理の監視体制整備

2. **中期（運用フェーズ）:**

   - Auth0 M2M認証への移行
   - パフォーマンス監視と最適化
   - セキュリティ監査の実施

3. **長期（スケール対応）:**
   - セッションストレージの最適化
   - 認証フローの更なる改善
   - 多要素認証の検討

## 参考資料

- [Auth0 Testing Guide](https://auth0.com/docs/test)
- [Playwright Authentication Testing](https://playwright.dev/docs/auth)
- [Auth0 Machine-to-Machine Applications](https://auth0.com/docs/get-started/applications/machine-to-machine-applications)
- [Nuxt.js Authentication Best Practices](https://nuxt.com/docs/guide/directory-structure/middleware#authentication)
