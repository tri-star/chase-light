# テスト戦略

## ステータス

承認済み

## コンテキスト

プロジェクトの成長に伴い、品質保証とリファクタリングの安全性を確保するため、包括的なテスト戦略の策定が必要となった。フロントエンド、バックエンド、E2Eテストの各レイヤーで一貫した方針を定める必要がある。

## 決定

### テストピラミッド

#### 概念

テストピラミッドは、効果的なテスト戦略を表現する概念モデル。下位レイヤーほど多くのテストを実行し、上位レイヤーほど少なく重要なテストに絞る。

```
     /\
    /  \     E2E テスト
   /____\    (少数・重要なフロー)
  /      \
 /        \   フィーチャーテスト  
/__________\  (中程度・機能検証)
\          /
 \        /   ユニットテスト
  \______/    (多数・詳細検証)
```

#### 配布比率

- **ユニットテスト**: 70% - 個別機能の詳細検証
- **フィーチャーテスト**: 20% - 機能統合の検証
- **E2Eテスト**: 10% - クリティカルフローの検証

#### レイヤー選択ガイドライン

**ユニットテストで検証すべき内容**
- 純粋関数のロジック
- 個別コンポーネントの動作
- エラーハンドリング
- 境界値テスト

**フィーチャーテストで検証すべき内容**
- ページレベルの機能
- コンポーネント間連携
- 状態管理統合
- API連携フロー

**E2Eテストで検証すべき内容**
- クリティカルユーザージャーニー
- ブラウザ互換性
- パフォーマンス
- セキュリティ要件

### ユニットテスト

#### 基本方針

- **コロケーション**を意識し、テスト対象に近い場所で管理する
- テスト対象ファイルと同階層に `__tests__/[ファイル名].test.ts` を作成する
- vitestのテストコードを記述する際、describe/testの名前は**日本語**で記述する
- **Parameterized test**での記述が望ましい場合は積極的に利用する
- `it('テスト名')` よりも `test('テスト名')` を利用する（日本語でテスト名を記述する場合testの方が自然なため）

#### スコープ

ユニットテストは**単一の関数、クラス、コンポーネント**の動作を検証する：

- **Pure Functions**: 入力に対する出力の正確性を検証
- **コンポーネント**: Props、イベント、レンダリング結果の検証
- **Composables**: 内部状態、戻り値、副作用の検証
- **Utility Functions**: 変換、計算、バリデーション処理の検証

#### テスト例

```typescript
// utils/formatDate.test.ts
describe('formatDate', () => {
  test.each([
    ['2023-01-01', 'YYYY/MM/DD', '2023/01/01'],
    ['2023-12-31', 'YYYY年MM月DD日', '2023年12月31日'],
    [null, 'YYYY/MM/DD', ''],
    [undefined, 'YYYY/MM/DD', '']
  ])('日付フォーマット: %s を %s 形式で変換', (input, format, expected) => {
    expect(formatDate(input, format)).toBe(expected)
  })

  test('不正な日付文字列の場合はエラーをスローする', () => {
    expect(() => formatDate('invalid-date', 'YYYY/MM/DD')).toThrow()
  })
})
```

#### 境界値テスト

以下の境界値を必ず検証する：

- **Null/Undefined**: 未定義値の処理
- **空文字列/空配列**: 空のデータの処理
- **最小/最大値**: 数値の範囲外値
- **不正な型**: 期待しない型の入力
- **ネットワークエラー**: API呼び出しの失敗

#### モッキング戦略

**Frontend固有**

- テストコード中では**Nuxt.js環境**が利用可能な想定とする
- `@nuxt/test-utils`のNuxt環境を活用し、`useRuntimeConfig`等のNuxt関数を自然に使用

**API呼び出しのモッキング**

```typescript
// composables/useAuth.test.ts
describe('useAuth', () => {
  test('ログイン成功時にトークンを保存する', async () => {
    // APIレスポンスをモック
    const mockResponse = { token: 'test-token', user: { id: 1 } }
    vi.mocked($fetch).mockResolvedValue(mockResponse)

    const { login } = useAuth()
    await login('test@example.com', 'password')

    expect(useAuthStore().token).toBe('test-token')
  })
})
```

**外部依存関係のモッキング**

- **APIクライアント**: `$fetch`をモック
- **ストレージ**: `localStorage`、`sessionStorage`をモック
- **ルーター**: `useRouter`、`useRoute`をモック
- **環境変数**: `useRuntimeConfig`をモック

### フィーチャーテスト

#### 目的

フィーチャーテストは**複数のコンポーネントやモジュールが連携して動作する機能**の統合検証を行う。ユニットテストとE2Eテストの中間に位置し、ユーザーの観点から重要な機能の動作を確認する。

#### スコープ

- **ページレベル機能**: ログイン、検索、フォーム送信など完結した機能
- **コンポーネント連携**: 親子コンポーネント間のデータフロー
- **状態管理統合**: ストア、コンポーザブル、API連携の総合動作
- **認証フロー**: ログイン状態に依存する機能の検証

#### フレームワーク選択

**Testing Library + Vitest**を採用：

- `@testing-library/vue`でコンポーネント統合テスト
- `@nuxt/test-utils`でNuxt環境での統合テスト
- 実際のDOMレンダリングによる検証

#### 外部依存関係の処理

**APIモッキング**

```typescript
// features/auth/login.feature.test.ts
describe('ログイン機能', () => {
  beforeEach(() => {
    // APIレスポンスを統一的にモック
    vi.mocked($fetch).mockImplementation((url) => {
      if (url === '/api/auth/login') {
        return Promise.resolve({ token: 'test-token' })
      }
      return Promise.reject(new Error('Not mocked'))
    })
  })

  test('正常なログインフロー', async () => {
    const { getByLabelText, getByRole } = render(LoginPage)
    
    await userEvent.type(getByLabelText('メールアドレス'), 'test@example.com')
    await userEvent.type(getByLabelText('パスワード'), 'password')
    await userEvent.click(getByRole('button', { name: 'ログイン' }))

    expect(useAuthStore().isAuthenticated).toBe(true)
  })
})
```

**データベース/ストレージ**

- テスト用のインメモリデータベースを使用
- `localStorage`、`sessionStorage`のモック化
- 状態の初期化・クリーンアップを各テストで実施

#### テスト実行環境

- **DOM環境**: jsdomまたは実ブラウザ環境
- **Nuxt統合**: `@nuxt/test-utils/runtime`でフルスタック環境
- **並列実行**: テスト間の状態分離を保証

#### 対象とする機能例

- **認証**: ログイン、ログアウト、トークン更新
- **検索**: フィルタリング、ページネーション、ソート
- **フォーム**: 入力検証、送信、エラーハンドリング
- **ナビゲーション**: ルーティング、権限制御
- **通知**: 成功/エラーメッセージの表示

### E2Eテスト

#### 目的

E2Eテストは**実際のユーザー体験を模倣し、システム全体の動作**を検証する。本番環境に近い状態でのアプリケーションの動作確認を行う。

#### スコープ

- **クリティカルユーザージャーニー**: ログイン→操作→ログアウトの完全なフロー
- **ブラウザ互換性**: 主要ブラウザでの動作確認
- **レスポンシブ対応**: デスクトップ・モバイルでのUI検証
- **パフォーマンス**: ページ読み込み速度、操作レスポンス

#### Playwright実装

**設定・構成**

- `packages/frontend/tests`配下にテストファイルを配置
- `playwright.config.ts`で実行環境とブラウザを設定
- テストデータの準備・クリーンアップ戦略

```typescript
// tests/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('認証フロー', () => {
  test('正常なログインからダッシュボードアクセス', async ({ page }) => {
    // ログインページにアクセス
    await page.goto('/login')
    
    // ログイン情報を入力
    await page.fill('[data-testid="email"]', 'test@example.com')
    await page.fill('[data-testid="password"]', 'password')
    await page.click('[data-testid="login-button"]')
    
    // ダッシュボードにリダイレクトされることを確認
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
  })
})
```

#### ワークフローの明確化

**実行フェーズ**

1. **Setup**: テストデータ準備、認証状態設定
2. **Action**: ユーザー操作の実行
3. **Assertion**: 期待される結果の検証
4. **Cleanup**: テストデータの削除、状態リセット

**データ管理**

- **シードデータ**: テスト用の基本データセット
- **モックAPI**: 外部API依存の排除
- **状態分離**: テスト間の独立性確保

#### テスト環境構成

**開発環境**

- ローカル開発サーバーとの連携
- ホットリロード対応での継続的テスト実行
- デバッグモードでのステップ実行

**CI/CD環境**

- ヘッドレスブラウザでの自動実行
- 複数ブラウザでの並列実行
- テスト結果レポートの生成とアーティファクト保存

#### 対象シナリオ

**コアフロー**

- ユーザー登録・認証
- プロフィール管理
- データ作成・更新・削除
- 検索・フィルタリング

**エッジケース**

- ネットワークエラー時の動作
- セッションタイムアウト
- 不正アクセスの拒否
- レート制限の動作

**注意**: この決定は今後backendのコードも書き始めた場合に適切とは限らないので、変更する可能性がある

### 統合ガイドライン

#### レイヤー間の協力関係

**重複の防止**
- 各レイヤーは異なる観点でテストを実行
- 上位レイヤーで検出された問題は、適切な下位レイヤーでテストを追加
- 同じ検証内容を複数レイヤーで重複実装しない

**段階的テスト実行**
1. **ユニットテスト**: 開発時に継続実行、高速フィードバック
2. **フィーチャーテスト**: 機能完成時に実行、統合確認
3. **E2Eテスト**: リリース前に実行、最終品質保証

#### テストデータ管理

**データ分離戦略**
- **ユニットテスト**: モックデータ、インメモリ状態
- **フィーチャーテスト**: テスト用ファイクスチャ、リセット可能な状態
- **E2Eテスト**: 専用テスト環境、シードデータ

**テストデータ原則**
- 各テストは独立実行可能
- テスト間でのデータ依存を排除
- 実行順序に依存しない設計

#### CI/CD統合

**実行タイミング**
- **Pull Request**: ユニット + フィーチャーテスト
- **Merge to Main**: 全テスト実行
- **デプロイ前**: E2Eテスト + パフォーマンステスト

**失敗時の対応**
- ユニットテスト失敗: 即座にPRブロック
- フィーチャーテスト失敗: 機能レビュー要求
- E2Eテスト失敗: デプロイ停止、緊急調査

#### 継続的改善

**メトリクス監視**
- テストカバレッジの測定と維持
- テスト実行時間の最適化
- 失敗率とその原因分析

**レビュープロセス**
- 月次テスト戦略レビュー
- 新機能開発時のテスト設計レビュー
- テストコード品質の継続的改善

## 根拠

### ユニットテスト

- **コロケーション**: テスト対象との距離を近くすることで、メンテナンス性と可読性を向上
- **日本語テスト名**: 業務要件を直接的に表現でき、非技術者でも理解しやすい
- **Nuxt環境**: モックを最小限に抑え、実際の動作により近いテストを実現

### フィーチャーテスト

- **Testing Library**: ユーザー中心の視点でのテスト実装を可能にする
- **統合検証**: コンポーネント間連携の確実な動作確認
- **実用的範囲**: E2Eテストほど重くなく、ユニットテストより包括的

### E2Eテスト

- **Playwright**: モダンなE2Eテストツールとして安定性とパフォーマンスを両立
- **Frontend中心**: 現在のアーキテクチャに適合
- **実環境検証**: ブラウザ互換性とパフォーマンスの確認

### テストピラミッド

- **効率性**: 適切なテスト配布により開発速度と品質を両立
- **メンテナンス性**: 各レイヤーの責任分担による保守コスト削減
- **早期発見**: 下位レイヤーでの問題検出により修正コスト削減

## 結果・影響

### 正の影響

- **テストの保守性向上**: レイヤー分離により適切な責任分担
- **実際の動作により近いテスト環境**: Nuxt統合とPlaywright活用
- **開発者の生産性向上**: 明確なガイドラインと自動化
- **品質保証の強化**: 包括的なテスト戦略による欠陥率削減
- **リファクタリング安全性**: 十分なテストカバレッジによる変更への自信

### 今後の課題

- **バックエンドAPI連携テストの方針策定**: 現在TBDの部分の明確化
- **テスト実行時間最適化**: CI/CD環境での効率的な実行
- **テストデータ管理**: 複雑なシナリオに対応するデータ戦略
- **パフォーマンステスト統合**: レスポンス時間とリソース使用量の監視

## 参考資料

- [認証に関するテスト戦略](docs/adr/ADR001-auth.md#testing-strategy)
- [@nuxt/test-utils公式ドキュメント](https://nuxt.com/docs/getting-started/testing)
